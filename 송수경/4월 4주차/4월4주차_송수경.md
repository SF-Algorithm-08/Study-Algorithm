# 4월 4주차
## 백준 1938: 통나무 옮기기
- 난이도: Gold 2
- 분류: bfs, 구현

### 아이디어
1. 가로,세로 를 1, 2로 정의한다.
1. 먼저 Tree 클래스를 선언하여 행/열 위치, 움직인 횟수, 가로/세로 정보를 넣는 생성자를 작성한다.
2. 입력받으며 B와 E가 만났을 경우를 처리해준다
    - 둘다 두번째 만났을 때가 중심점이다(상좌부터 탐색하므로)
3. bfs를 수행하여 답을 리턴한다.
    - `difVisited`는 가로형태 새로형태에 따른 방문 상태를 나타낸다
4. 수행 중 목적지에 도착하면 그곳까지의 움직임 횟수를 리턴한다.
5. 아직 도달하지 못했다면 상하좌우 및 회전 이동을 수행한다.
6. `checkMove` 메소드는 이동을 위해 베지 않은 나무로 인해 방해가 안되는지를 판단해준다.

### 회고
visited를 int형으로 선언하니 회전 처리를 하기에 용이했다
이 문제는 정말 있는 그대로 구현하면 되는 문제라서 잘 풀 것 같았는데 오류를 찾지 못했다 ㅠㅠ

___
## 백준 1043: 거짓말
- 난이도: Gold 4
- 분류: 자료구조, 분리 집합, 그래프 이론, 그래프 탐색

### 아이디어
1. `head[]`배열을 선언하여 인덱스값을 넣어준다
2. 파티에 오는 사람들에 대해 입력받아 저장하며 동시에 같은 파티에 오는 사람들을 그룹화한다(**union**)
3. 진실을 아는 사람의 경우 전체 인원에 대해 탐색하며 같은 그룹에 있는 사람을 모두 찾아 진실을 안다는 것을 표시한다 (**find**)
4. 진실을 아는 최소 사람 표시 완성
5. 나머지 사람들에게 모두 과장하면 되므로 진실을 모르는 사람으로만 이루어진 행 개수를 세어준다.

### 회고
유니온파인드를 사용한다는 아이디어가 떠오르지 않아서 분류를 참고해서 풀었다,, 방법을 알고나니 재미있게 풀었음

____
## 백준 4386: 촌수계산
- 난이도: Gold 4
- 분류: 그래프 이론, 최소 스패닝 트리

### 아이디어
1. 간선의 수가 많지 않으므로 크루스칼 알고리즘을 활용한다.
2. 별과 별 사이의 거리를 구하며 간선 정보를 list에 저장한다.
3. 짧은 거리부터 오름차순으로 정렬한다. (간선 클래스에 `compareTo`메서드 활용)
4. 각각의 인덱스를 배열 값으로 넣어 초기화한다.
5. list에서 순서대로 고르면 별 사이의 거리가 짧은 것부터 고르게 되므로 별들이 연결되어있지 않다면 별과 별 사이를 연결한다.

### 회고
크루스칼 알고리즘을 연습하기 좋은 문제였다.