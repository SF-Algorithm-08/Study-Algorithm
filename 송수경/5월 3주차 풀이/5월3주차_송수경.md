# 5월 3주차
## 백준 16472: 고냥이
- 난이도: Gold 2
- 분류: 이분 탐색, 투 포인터

### 아이디어
1. 알파벳을 사용했는지 여부를 나타내는 boolean 배열과 알파벳 및 최대 인덱스 정보를 담는 ArrayList를 활용한다.
2. 문자열의 문자를 하나씩 읽으면서 아래 경우에 따른 처리를 한다.
    - 기존에 인식한 알파벳인 경우: list에 담긴 인덱스 정보 갱신
    - 새로운 알파벳이면서 추가로 인식가능한 경우: 추가로 인식
    - 새로운 알파벳이면서 이미 인식가능한 개수를 채운 경우: 가장 긴 길이를 유지할 수 있도록 기존에 인식한 알파벳 지우기 -> list에 담긴 idx값 이용
3. maxlen값을 갱신하고, 문자열을 끝까지 검사했다면 maxlen 출력

### 회고
md를 작성하면서 보니 ArrayList만으로 처리할 수 있지 않았을까 생각이 들었다. remove와 add를 반복하는 것이 아니라 Alphabet 객체에 접근해서 idx 속성을 업데이트 했으면 더 좋았을 것 같다..!
그리고 새로운 문자를 인식해야하는 경우 때문에 좀 복잡하게 코드를 작성한 것 같다,, 효율적인 방법이 생각이 안났다 ㅠ

___
## 백준 8913: 문자열 뽑기
- 난이도: Gold 3
- 분류: 자료 구조,다이나믹 프로그래밍,트리를 사용한 집합과 맵

### 아이디어
1. 연속된 a, b의 상태에 따라 개수를 세어서 그룹을 나누어준다.
    - ex) aaabb -> 3, 2
2. 각 그룹을 하나씩 없애보며 새로 바뀐 상태를 우선순위 큐에 넣는다.
    - 이 때 문자열의 길이를 기준으로 오름차순 정렬하여 적은 문자가 남은 문자열부터 처리하도록 한다. (이렇게 하지 않으면 메모리 초과)
3. 그룹이 하나 남았을 때 2이상이면 빈 문자열로 바꿀 수 있으므로 1을 리턴하고 모든 경우를 처리해도 리턴되지 못하면 빈 문자열을 만들 수 없다는 의미이므로 0을 리턴한다.

### 회고
문제를 풀고 나서 분류 유형이 dp라서 놀랐다. 더 효율적인 풀이에 대해 고민해봐야겠다는 생각이 들었다.

____
## 백준 16234: 인구 이동
- 난이도: Gold 5
- 분류: 너비 우선 탐색,그래프 이론,그래프 탐색,구현,시뮬레이션

### 아이디어
1. 인구가 이동할 수 없을 때까지 while문을 반복한다.
2. 한번 while문을 돌 때 먼저 국경선을 연다.
3. 국경을 없앨 부분을 `area`를 통해 1부터 차례대로 표시할 것 이므로 0값이라면 bfs 함수를 통해 국경을 open한다.
4. 차이가 L과 R 사이라면 하나의 연합으로 표시한다.
5. 위 3, 4 과정을 통해 국경선을 모두 열었다면 그 정보를 가지고 `move()`함수를 통해 인구를 이동시킨다.
6. `change`변수에 이동이 이루어졌으면 true를 담는다. 그러나 다음 인구 이동을 위해 바로 리턴하지는 않음에 주의한다.
7. 모든 곳을 처리했다면 `change`를 반환하고 그 값이 false면 이동이 안이루어졌다는 것이므로 break한다.

### 회고
역시 시뮬이라 그런지 생각보다 복잡했다. 그래도 함수를 여러개로 나누니 훨씬 구현하기 용이했다!