# 4월 3주차
## 백준 15685: 드래곤 커브 
- 난이도: Gold 4
- 분류: 시뮬레이션, 구현

### 아이디어
1. 최초로 주어진 좌표와 방향을 통해 0세대를 먼저 ArrayList에 추가하고, 방향으로 구한 0세대의 새로운 좌표를 기준점으로 설정한다.
    - 기준점: 회전이동을 하는 기준점으로 리스트 내에서의 인덱스를 의미
2. `g`에 대해 for문을 수행하면서 그 세대에 대해 더해지는 좌표를 ArrayList에 추가하고, 좌표가 `0~100` 범위에 포함된다면 true 처리를 해준다.
3. 이 때 기준점은 새 좌표를 구할 필요 없으므로 `continue`처리해준다.
4. **리스트의 0번째 요소(최초에 주어지는 점)가 옮겨지는 점이 다음 세대의 기준점**이 되므로 그 때 기준점을 갱신한다.
5. 새로운 좌표를 구하는 방법
    - 문제에서 주어진 좌표계의 증가 방향이 우하이다.
    - 익숙한 방향은 우상이므로 x축 기준으로 대칭이동해서 풀었다.
    - 이에 따라 회전 방향도 변환되어 반시계 방향으로 풀었다.
    - 기준점이 `(X0, Y0)`이고 이동할 좌표가 `(X1, Y1)`이라면 새로운 좌표 `(X2, Y2)`는 다음과 같다.  
    `(X2, Y2) = (X0-(Y1-Y0), Y0+(X2-X0))`
6. 드래곤 커브 구하기가 완료되었다면 1x1 사각형을 이루는 점이 모두 true처리 된 경우 1씩 더해준 값을 출력한다.

### 회고
놀면서 집중 안하고 문제를 풀려고 했더니 초반부터 생각이 꼬여서 대칭이동만 한참 생각했다. 풀어놓고도 계속 헷갈리긴 하는중.. 그리고 문제의 조건도 건성으로 봐서 걸리는 부분이 많아 좀 더 오래 걸렸던 것 같다 

___
## 백준 2502: 떡 먹는 호랑이 
- 난이도: Silver 1
- 분류: dp, 수학

### 아이디어
1. 첫 번째 날짜에 준 떡의 개수를 a, 두 번째 날짜에 준 떡의 개수를 b라고 생각해본다.
2. 문제에서 수열의 규칙을 알려줬으므로 그 규칙에 따라 입력으로 주어진 날짜의 a 계수, b 계수를 구한다.
3. a가 1이상이므로 a를 1부터 시작하여 총 떡의 개수에서 `a*a의 계수`를 구한다.
4. `떡 개수 - a*a의 계수`를 b의 계수로 나누었을 때 나누어 떨어질 때 까지 a를 1씩 늘려가며 3을 반복한다.
5. a, b가 꼭 존재한다고 했으므로 나누어 떨어질 때 반복문을 종료하고 결과를 출력한다.

### 회고
보통은 시작점을 기준으로 수열의 규칙을 찾아내는 문제를 풀었었는데, 이번에는 반대로 수열의 규칙과 결과값을 가지고 초기값을 찾아내는 것이 문제였다. 재밌게 풀었다!
그리고 나는 a, b의 각각의 계수를 위해 2차원 배열을 활용했는데, 풀고 나서 보니 어차피 a와 b의 규칙이 같아 1차원으로만 해도 가능했다.

____
## 백준 2644: 촌수계산
- 난이도: Silver 2
- 분류: bfs, dfs, 그래프

### 아이디어
1. `[][][0]`에 인접한 수들을 boolean 배열에 true로 표시하는 인접 행렬을 만든다.
2. 촌수를 세어야 하는 수 부터 시작하여 인접한 부분으로의 bfs를 수행한다.
    - 방문 표시는 `[][][1]`에 한다.
3. 이 때 큐 안에는 `Integer[]`을 활용하여 `{노드 번호, 촌 수}` 정보를 담는다.
4. bfs를 수행하며 촌 수를 세어야 하는 지점에 도착하면 몇 촌인지 출력한다.
5. while문을 빠져나왔다면 적절한 촌 수를 찾지 못한 것이므로 문제의 조건대로 -1을 출력한다.

### 회고
인접 행렬로 못 푸는 경우도 많으니 앞으로는 다른 방법으로 연습을 더 하는 것이 좋을 것 같다.