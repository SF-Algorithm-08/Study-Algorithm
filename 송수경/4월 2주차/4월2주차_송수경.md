# 4월 2주차
## 백준 4811 : 알약
- 난이도: Gold 5
- 분류: dp

### 아이디어
1. dp 배열을 이차원으로 선언하여 `dp[W][H]`를 나타내도록 한다.
2. 길이가 k인 문자열은 길이가 k-1인 문자열에 W또는 H가 온다는 아이디어를 활용한다.
    - 점화식: `dp[w][h] = dp[w-1][h] + dp[w][h-1]

### 회고
점화식을 바로 못찾아서 꽤 고민했다. 완전한 알약, 쪼개진 알약을 나누어 생각하는 것이 핵심이었다!

____
## 백준 5525: IOIOI
- 난이도: Silver 2
- 분류: 문자열

### 아이디어
1. 입력되는 개수가 고정되어있으므로 편하게 Scanner를 사용해도 된다.
2. 문자열을 `0`번째 인덱스부터 `M(문자열의 길이)-2`번째까지 검사하면서 I를 찾는다.
3. I를 찾았다면 뒤에 OI가 몇 번(`cnt`)이나 연속되었는지 찾는다.
4. `연속된 OI의 개수 - N(IOI패턴에서 O의 개수) + 1` 값을 더해 갱신한다 (단 최솟값은 하나도 포함되어있지 않은 경우이므로 0)
    - ex. N=2일때 `IOIOI`를 찾아야 함. 연속한 OI의 개수가 4로 `IOIOIOIOI`라면, 그 안에 포함된 Pn의 개수는 `4-2+1 = 3`이다.
5. 조건을 벗어난 경우에는 그 벗어난 위치부터 다시 검사한다.(`idx`)
6. 끝까지 검사 후 정답을 출력한다.

### 회고
연속하는 OI 검사 후 다음 인덱스로 이동하는 부분에서 좀 헷갈렸다. 그래도 다행히 실수 없이 한번에 통과했다! 문자열 문제가 은근 난이도에 비해서 꼼꼼하게 풀어야 하는 것 같다..  

___
## 백준 2589: 보물섬
- 난이도: Gold 5
- 분류: bfs

### 아이디어
1. 입력받은 배열을 처음부터 탐색하며 L을 만날 때마다 그 지점부터 연결된 L들까지의 거리를 구한다 (bfs 수행)
2. 거리를 구하고, 최댓값을 갱신하면서 가장 먼 거리를 구한다.

### 회고
L을 만날때마다 bfs를 수행하면 시간초과가 나지 않을까 했는데, 생각보다 오래 걸리지 않았다. 의외로 문제에서 말한 그대로 구현하면 풀리는 문제였음..!