# 3월 3주차
## 백준 2573 : 빙산
- 난이도: Gold 4
- 분류: 구현, 그래프 탐색, BFS, DFS

### 아이디어
1. 바다와 인접한 부분이라는 조건에 맞추어 빙산이 존재하는 칸의 값을 감소시키고, 또 빙산의 개수를 체크하는 등 처리해야할 것이 많으므로 기능마다 함수로 쪼갠다.
2. 입력받을 때 바다의 죄표를 ArrayList에 담는다.
2. 최초 상태 체크: 빙산이 없으면 0을 출력하고 종료한다.
4. day++ -> 녹이고 -> 상태 체크하고  의 반복
3. `solve()`: 재귀를 위한 함수
4. `meltIce()`: ArrayList.size만큼 반복하면서 빙산을 녹인다.
6. `checkIce()`: 빙산 상태를 체크한다
    - 전체 배열에서 0이 아닌곳 세기(cnt1 -> ArrayList으로 개선)
    - bfs를 통해 인접한 빙산을 체크한다
    - **위의 두 수를 비교하여 같으면 빙산이 하나, 다르면 빙산이 갈라졌다는 의미, 0이면 다 녹아버린 것**

### 회고
빙산을 녹이고, 개수를 세는 등 해야 할 작업이 많아서 있는 그대로 작성하기가 너무 어렵게 느껴졌다. 하루 지나고 다시 천천히 보면서 기능별로 함수를 나누었더니 훨씬 풀이가 수월했다. 이번 주 보충 기간동안 교수님께서 구현 전에 계획을 탄탄하게 세우는 것을 강조하셨는데 그 중요성을 다시 한 번 깨달았다..
여담) 런타임 에러 (NoSuchElement)가 발생했었는데 행렬 크기를 잘못 지정했었다. 바보같은 실수 안하게 조심^__^
____
## 백준 5052: 전화번호 목록
- 난이도: Gold 4
- 분류: 자료 구조, 정렬, 문자열, 트리, 트라이

### 아이디어
1. 길이가 짧은 전화번호가 다른 전화번호의 시작 지점에 있는지를 판별하면 된다.
2. 숫자 형태로 주어지므로 sort를 하는 것이 효율적이다.
3. sort하였다면 인접한 2개만 비교하면 된다.

### 회고
생각보다 쉬운 문제였다. trim()은 자주 썼는데 사이에 있는 공백 처리를 오랜만에 해서 검색해서 사용했다. sort를 할 때 처음에는 숫자임에 집중하여 정수(Long)형으로 바꾼 다음 처리를 했었는데, 그렇게 하니 오히려 format 에러가 발생할 때도 있고 효율적이지 않았다. String 자체로 sort하여 처리!

___
## 백준 6118: 숨바꼭질
- 난이도: Silver 1
- 분류: 그래프 탐색, 너비 우선 탐색

### 아이디어
1. 입력을 받으며 연결된 부분은 값을 이차원 배열 값을 true로 표시한다.
2. BFS를 수행하는 동안 거리별로 헛간이 몇 개인지 체크해야 하므로 배열을 선언한 후 탐색을 시작한다.
3. 거리에 대한 정보는 Node 클래스를 만들어 depth 로 넣어준다.
4. 가장 멀리 가야 하기 때문에 모든 지점을 탐색한다.

### 회고
Queue 사용을 하면서 중복되는 지점이 있는지 계속 메모리 초과가 떠서 고생했다. 근데 아직 해결을 못해서 좀 더 찾아봐야겠다 ㅠㅠ