# 3월 3주차
## 백준 2573 : 빙산
- 난이도: Gold 4
- 분류: 구현, 그래프 탐색, BFS, DFS

### 아이디어
1. 바다와 인접한 부분이라는 조건에 맞추어 빙산이 존재하는 칸의 값을 감소시키고, 또 빙산의 개수를 체크하는 등 처리해야할 것이 많으므로 기능마다 함수로 쪼갠다.
2. 입력받을 때 바다의 죄표를 ArrayList에 담는다.
2. 최초 상태 체크: 빙산이 없으면 0을 출력하고 종료한다.
4. day++ -> 녹이고 -> 상태 체크하고  의 반복
3. `solve()`: 재귀를 위한 함수
4. `meltIce()`: ArrayList.size만큼 반복하면서 빙산을 녹인다.
6. `checkIce()`: 빙산 상태를 체크한다
    - 전체 배열에서 0이 아닌곳 세기(cnt1 -> ArrayList으로 개선)
    - bfs를 통해 인접한 빙산을 체크한다
    - **위의 두 수를 비교하여 같으면 빙산이 하나, 다르면 빙산이 갈라졌다는 의미, 0이면 다 녹아버린 것**

### 회고
며칠을 풀지 못하다가 겨우 풀었는데 런타임 에러가 발생한다..! 기능별로 함수를 나누니 훨씬 수월해졌다. 특히 빙산을 녹일 때 무엇을 기준으로 해야 할 지가 헷갈렸다. 그래도 오늘 아침까지 손도 못 대다가 풀긴 풀었다.. 오류가 나는 부분은 고쳐봐야함
(java 파일에 두번째 테케에서 문제가 발생한다. 디버깅을 함께해주세요..ㅎ)
____
## 백준 5052: 전화번호 목록
- 난이도: Gold 4
- 분류: 자료 구조, 정렬, 문자열, 트리, 트라이

### 아이디어
1. 길이가 짧은 전화번호가 다른 전화번호의 시작 지점에 있는지를 판별하면 된다.
2. 숫자 형태로 주어지므로 sort를 하는 것이 효율적이다.
3. sort하였다면 인접한 2개만 비교하면 된다.

### 회고
생각보다 쉬운 문제였다. trim()은 자주 썼는데 사이에 있는 공백 처리를 오랜만에 해서 검색해서 사용했다. sort를 할 때 처음에는 숫자임에 집중하여 정수(Long)형으로 바꾼 다음 처리를 했었는데, 그렇게 하니 오히려 format 에러가 발생할 때도 있고 효율적이지 않았다. String 자체로 sort하여 처리!

___
## 백준 6118: 숨바꼭질
- 난이도: Silver 1
- 분류: 그래프 탐색, 너비 우선 탐색

### 아이디어
1. 입력을 받으며 연결된 부분은 값을 이차원 배열 값을 true로 표시한다.
2. BFS를 수행하는 동안 거리별로 헛간이 몇 개인지 체크해야 하므로 배열을 선언한 후 탐색을 시작한다.
3. 거리에 대한 정보는 Node 클래스를 만들어 depth 로 넣어준다.
4. 가장 멀리 가야 하기 때문에 모든 지점을 탐색한다.

### 회고
Queue 사용을 하면서 중복되는 지점이 있는지 계속 메모리 초과가 떠서 고생했다. 근데 아직 해결을 못해서 좀 더 찾아봐야겠다 ㅠㅠ