# 4월 1주차
## 백준 17845 : 수강 과목
- 난이도: Gold 5
- 분류: dp, 배낭문제

### 아이디어
1. 전형적인 배낭문제이다! 배낭 문제 알고리즘을 익히고 그대로 구현해보는 연습

### 회고
일부러 며칠 간격 두고 풀어봤는데 그새 가물가물 해졌었음

____
## 백준 2608: 로마 숫자
- 난이도: Silver 1
- 분류: 구현, 문자열, 수학

### 아이디어
1. Hashmap으로 기호와 숫자를 저장하여 사전처럼 사용할 수 있도록 한다.
2. 입력받은 두 Sting 문자에 대해 위에서 정의한 해쉬맵에서 숫자값을 찾아 int로 변환한다. (StringToInt)
3. 변환한 두 수를 합해 기호로 변환한다.
4. 최소의 문자 길이로 반환되어야 하므로 큰 수부터 비교한다. (IntToString)
5. 이 때 한 자리라면 hashmap을 활용하고 두 자리(즉, 두 값의 차이)라면 IntToString 함수 내에서 미리 선언한 배열 내에서 찾는다.
6. 변환된 기호를 출력한다.

### 회고
숫자를 문자열로 변환할 때 차이 값을 활용해야 하는 경우 처리를 어떻게 해야할지 고민이 되었다. 해시맵 내에 차이에 대한 값들도 넣어 처리해도 될 것 같다.  
그런데 해시맵이나 배열을 쓰지 않고 문제에서 주어진대로 정말 하나하나 비교를 해도 시간과 메모리 사용에 드라마틱한 차이는 없어보였다. 

___
## 백준 3187: 양치기 꿍
- 난이도: Silver 2
- 분류: bfs, dfs, 그래프 이론, 그래프 탐색

### 아이디어
1. 한 울타리에 존재하는 늑대와 양의 수를 비교해 남아있는 늑대와 양의 수를 갱신해야 한다.
2. 각 울타리마다 각각 bfs탐색을 수행한다.
3. 늑대와 양은 꼭 울타리 안에 있다고 했으므로 이중 for문으로 행,열을 탐색하면서 양과 늑대를 발견하면 bfs 함수를 호출한다.
4. int[]를 담는 Queue를 생성하고 울타리 내부를 탐색한다 (#를 만나면 continue)
    - 탐색하면서 방문한 곳은 visited = true 처리
5. 울타리 내부를 탐색하면서 구한 양과 늑대의 값을 비교해 `양 수 > 늑대 수`라면 양 값만 갱신하고, else의 경우 늑대 값만 갱신한다.
6. 3번으로 돌아가 반복한다.
    - 이 때, 이미 방문한 양,늑대는 visited 처리가 되어있으므로 같은 울타리는 재방문하지 않는다.
7. 행, 열을 모두 탐색했다면 양, 늑대 값을 출력한다.

### 회고
bfs를 수행할 기준을 찾는 것이 중요한 문제가 많은 것 같다. 울타리 안에 늑대와 양이 있다는 조건이 있어서 수월한 편이었다고 생각함.