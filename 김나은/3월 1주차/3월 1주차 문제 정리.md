#  3월 1주차 풀이
## BOJ S3 14425 문자열 집합
### **Idea**
* 2중 for문을 돌면서 M개의 문자열 내에 집합 S(N개의 문자열)에 몇 개가 포함되는지 카운트한다. 
* equals를 사용하여 문자열이 일치하는지 확인한다.

### 코드
```java
	for (int i = 0; i < N; i++) {
		str[i] = br.readLine();
	}

	for (int i = 0; i < M; i++) {
		String line = br.readLine();
		for (int j = 0; j < N; j++) {
			if (str[j].equals(line)) ans++;
		}
	}
```

### 후기

1 ≤ N, M ≤ 10000 이라 2중 for문을 쓰면 시간초과가 나지 않을까 걱정했는데 Java는 6초여서 한번에 통과가 되었다.
다른 사람 풀이 중 Hash Set을 이용한 풀이는 시간이 획기적으로 짧았다. 만약 시간 제한이 타이트하다면 이를 사용하는 것이 좋을 것 같다!

---

## BOJ S1 1074 Z
### **Idea**
* 시간 제한이 0.5초 이므로 완탐으로 풀 수 없다!!!
* 해당 좌표가 제 1사분면, 제 2사분면, 제 3사분면, 제 4사분면 중 어느 곳에 해당하는지 파악하여 탐색을 하지 않고 탐색 횟수(n*n)를 더해준다

### 코드

```java
	while (n > 1) {
		n /= 2;
		if (r < row + n && c < col + n) { // 왼쪽 위 (제 1사분면 - 더해줄 것이 없다)
		} else if (r < row + n && c >= col + n) { // 오른쪽 위(제 2사분면)
			ans += n * n;
			col += n;
		} else if (r >= row + n && c < col + n) { // 왼쪽 아래(제 3사분면)
			ans += n * n * 2;
			row += n;
		} else { // 오른쪽 아래(제 4사분면)
			ans += n * n * 3;
			row += n;
			col += n;
		}
	}
```

### 후기

처음 문제를 봤을 때는 쿼드트리와 비슷하여 재귀를 이용해서 풀었는데 계속 시간초과가 났다. 재귀를 포기하고 나서야 비로소 통과할 수 있었다.
다른 사람은 재귀로도 통과했던데 뭐가 문제인지 모르겠다...

----

## BOJ G3 1377 버블 소트
### **Idea**
* 문제에 제시된 코드를 사용하면 시간 초과..
* 구하고자 하는 값(i)은 "버블 소트의 수행 횟수"이다
* 버블 소트는 수행할 때마다 가장 큰 값이 가장 오른쪽으로 가도록 정렬하는 로직으로, 반대로 말하면 작은 값은 왼쪽으로 한칸씩 움직인다!
* 따라서 문제에서 구해야하는 값은 처음 인덱스와 정렬 후의 인덱스의 차이 중 가장 큰 값+1 이다. 

### 코드

```java
	for (int i = 1; i <= N; i++) {
		arr[i] = new Pos(Integer.parseInt(br.readLine()), i);
	}
	Arrays.sort(arr, 1, N + 1); // fromIndex(inclusive) to the index toIndex(exclusive)

	int max = 0;
	for (int i = 1; i <= N; i++) {
		max = Math.max(max, arr[i].idx - i);
	}
```

### 후기

처음에는 문제에 제시된 코드를 복붙했는데 시간초과가 났다.
초기 값과 인덱스를 저장해야하고, 정렬도 해야해서 배열보다는 클래스를 이용하는 것이 좋겠다고 생각하였다.
Arrays.sort() 시작인덱스는 포함되고 끝인덱스는 포함되지 않는다는 것을 알게되었다.