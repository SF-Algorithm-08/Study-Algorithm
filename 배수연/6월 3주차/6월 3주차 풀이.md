# 6월 3주차 풀이

# BOJ_S1_1389 - 케빈 베이컨의 6단계 법칙🥓

### Idea

- 그래프, 플로이드와샬
 - 전체 map을 max값인 99로 초기화
 - 한 번에 연결된다고 입력받으면 map값을 1로 바꿔주기
 - 3중 포문으로 플로이드 구현하면서 각 노드에 도달할 수 있는 최소값으로 갱신
 - 마지막에 이중 포문 돌면서 각 노드에서의 케빈 베이컨 수를 구하고, 그게 최소일 때의 사람을 갱신해가며 구함

### 정리

처음에 인접 리스트로 풀어야 하나? 고민했는데 플로이드와샬로 수를 세가면서 구하면 되겠다고 생각했다. 플로이드 와샬은 알고리즘 자체가 간단해서 오랜만에 풀어도 쉽게 구현할 수 있는 것 같다.

------

# BOJ_G4_1939 - 중량제한🌉

### Idea

- UnionFind
- 구체적인 그래프 이론이 있다기보다는 자료구조와 분리집합을 잘 조합해서 해결하는 문제인 것 같다.
 - cost의 max를 알아야 하기 때문에 pq를 이용해서from, to, cost를 cost 기준 내림차순으로 저장했고, 노드들을 union해가다가 두 공장이 연결되면 그 때의 cost를 바로 리턴

### 정리

처음에는 단순히 노드들을 union으로 묶어주면 된다고 생각했는데, cost값을 비교할 수가 없어서 고민을 좀 많이 했다. 그래서 pq로 쭉 저장하고 union해가면서 결과를 찾는 방법을 생각했다.

------

# BOJ_G1_1981 - 배열에서 이동📐

### Idea

- BFS, 투포인터, 구글링!
- map에 들어가는 값들을 중복 없이 list에 넣고 오름차순으로 정렬
- min, max값을 0으로 지정해두고 탐색 가능 여부를 판단하여 최대-최소의 최소값을 구하기
- 탐색 가능 여부 BFS
  - map의 (0, 0) 값이 최소값~최대값 범위 밖에 있다면 바로 return false
  - 전체적인 부분은 일반 BFS와 동일, (N, N)에 도달하면 return true
  - 4방 탐색으로 이동할 칸의 값이 최소값~최대값 범위 내에 있다면 queue에 넣기

### 정리

BFS를 이용해서 단순히 map 탐색하는 것까지는 알겠는데 각 경로의 gap을 어떻게 지정해야 할지 머리가 복잡했다. 그래서 알고리즘 구분을 봤는데 이분탐색이 있어서 정말 의아했다. 봐도 감이 정말 안와서 구글링을 해서 해결했다. 참고한 블로그의 코드에서 map 값을 미리 저장해두고 투포인터 방식으로 해결한게 너무 인상적이었다. 코드 이해하는 것도 조금 오래 걸리긴 했지만 상당히 신박하게 해결한 것 같고, 다음에 다시 아이디어를 내서 풀어보고 싶다.