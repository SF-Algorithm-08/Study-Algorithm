# 6월 2주차 풀이

# BOJ_G5_14502 - 연구소🧫

### Idea

- 구현, BFS

- 과정

- ```java
  1. 입력받으면서 바이러스의 위치를 저장
  2. 전체 0~N*M-1개 중 3개의 점을 선택해서 벽 세우기(재귀)
  3. 초기 바이러스 위치 기준으로 BFS 탐색하면서 바이러스 퍼트리기
  4. 안전 영역 구하기
  	4.1 idea1 : idx==3일 때 초기화해주고, 마지막에 map에 2 퍼트려가면서 0인 부분 카운트하기 => 어디선가 잘못됨...
      4.2 idea2 : 안전 영역 = 전체 map 크기 - 초기 벽 개수 - 3 - 바이러스 개수
  ```

### 정리

시뮬레이션 돌리는 로직 자체는 어렵지 않게 생각했는데, 안전 영역 구하는 부분에서 조금 애먹었다. 처음에는 map에 바이러스 퍼지는걸 다 표시하고 초기화해주려고 했는데 이상하게 답이 계속 안나왔다. 어디가 잘못됐는지 찾지를 못해서 그냥 다른 방식으로 해결했다.

------

# BOJ_G4_1963 - 소수경로🎰

### Idea

- 숫자, 소수, BFS
- 시작 숫자에서부터 자리수 별로 값을 하나씩 바꿔가면서 그 수가 소수인지 판단
 - 숫자 바꿔보다가 목표값과 같다면 거기까지 도달하는 데 걸린 횟수를 최소값으로 갱신
 - BFS에서 특정 수가 소수인지 판별하는 메소드가 많이 호출됨 => 1000~9999 값들을 미리 소수인지 검사해서 저장해두고 배열값 참조만 해주기

### Code

```java
/* 2중 for문을 통해 왼쪽부터 i번째 자리의 수를 j로 변경하는 로직 */
for(int i = 0 ; i<4 ; i++) {
	for(int j = 0 ; j<=9 ; j++) {
      	 // 천의 자리 수가 0일 수는 없다
		if(i == 0 && j == 0) continue;
		// 새로운 수 만들기
		String origin = String.valueOf(temp_num); // 수를 문자로
		int mul = 3-i; // 10의 몇제곱인지(자리수)
		int new_num = (int) (temp_num - Math.pow(10, mul)*(origin.charAt(i)-'0')); // 기존 수(temp_num)에서 i자리에 있는 수를 뺌 (1033에서 i=2라면, 1003으로)
		new_num += Math.pow(10, mul)*j; // j=5라면, new_num에 50 더해서 1053으로 만들기
		if(new_num>=1000 && prime[new_num]) {
			queue.offer(new int[] {new_num, cnt+1});
		}
	}
}
```

### 정리

처음에는 숫자를 하나 생성할 때마다 소수 판별을 해주려고 했는데, 그렇게 하면 메소드 호출이 너무 많이 될 것 같아서 미리 저장해두는 방식으로 변경했다. 생성할 수의 경우가 9000개밖에 되지 않아서 미리 소수인지 아닌지를 저장해두는게 더 나은 것 같다.

------

# BOJ_G2_1561 - 놀이공원🎢

### Idea

- 이분탐색

- 예제 분석

- ```java
  예제  1 2 3 4 5
  1분 : 1 1 1 1 1 => 5명
  2분 : 2 1 1 1 1 => 6명 + 5
  3분 : 3 1 1 1 1 => 7명 + 5
  4분 : 4 2 1 1 1 => 9명 + 5
  5분 : 5 2 1 1 1 => 10명 + 5
  6분 : 6 3 2 1 1 => 13명 + 5
  7분 : 7 3 2 1 1 => 14명 + 5
  8분 : 8 4 2 2 1 => 17명 + 5
  7->8분에서 1, 2, 4번 놀이기구에 탑승했으므로 4번이 마지막
  ```

- 각 놀이기구에 걸리는 시간을 해당 분에서 나누고 다 더하면 그 시간까지 탑승 가능한 인원 수를 구할 수 있다.

 - 이분으로 탐색하면서 전체 N이 커버되는 시간 확인하기
 - 그 직전 시간에서의 총 인원 수를 구하고, 시간이 바뀔 때 몇 번째 놀이기구에 사람이 탑승했는지 보기

### 정리

N이 매우 컸기 때문에 전부 탐색하면 시간 초과가 날 것이라고 생각했다. 그래서 예제를 분석하며 해당 분에서 각 놀이기구에 걸리는 시간을 나눈 값들을 더하면 된다는 규칙을 먼저 찾았고, 이분 탐색으로 걸러가면 되겠다고 생각했다. long type도 실수하지 않고 적절하게 잘 이용해서 스스로가 뿌듯하다.