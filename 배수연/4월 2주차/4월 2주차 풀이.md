# 4월 2주차 풀이

# BOJ_S2_5525 - IOIOI

### Idea

첫 번째 아이디어) N에 따른 IOIOI 문자열을 생성해두고 for 반복문을 돌면서, 입력받은 문자열의 I로 시작하는 부분부터 IOIOI와 같은 길이로 substring한 뒤 equals 비교 => *시간초과*

두 번째 아이디어)  for(0부터 M-2 미만까지) 반복하면서 I가 나오면 while i+=2로 반복하면서 "OI"가 나오는 횟수 세기 -> N번 만큼 나오면 ans++, 문자열이 IOIOI이고 N=1이면 두 번 반복되니까 ans++할 때 OI가 나온 횟수를 --해주고 다음 반복문을 돌게 한다 => *StringOutOfIndex*

세 번째 아이디어) 두 번째 아이디어에서 for-while 이중으로 반복하는걸 while 한 번만 반복하도록 수정. I를 만나면 뒤에 OI가 따라오는지 검색하지 말고 바로 IOI랑 일치하는지 확인. 다른 로직은 일치.

### 정리

쉽게 보고 접근했는데 생각보다 고민도 많이 하고 시간도 오래걸렸다. 자꾸 인덱스 오류가 떠서 생각하고 또 생각했는데 내 생각이 너무 맞는 것 같았고 조금씩 다르게 넣어봐도 다 틀렸다고 나와서 슬슬 짜증이 났다. 그래서 더 간단하게 새로 짜봤는데 맞다고 나왔다. S2 치고는 오래 걸렸는데 다 풀고 생각해보니까 KMP 알고리즘 이용하면 될 것 같았다.

------

# BOJ_G5_2589 - 보물섬

### Idea

- BFS
- visited[][] 배열 선언해서 육지의 각 칸을 방문하는 데에 걸린 길이를 최대값으로 갱신하면서 저장한다.
- H와 W 혼동 주의!

### 정리

전형적인 BFS 문제라고 생각하고 후루룩 풀었는데 콘솔에서 실행할 때 인덱스 오류가 발생했다. 아이디어에 기재된 것처럼 H와 W를 잘못 생각해서 중간에 잘못 표시한 부분이 있었다. 좀 차분하게 숨을 고르면서 코드를 짜버릇 해야하는데 자꾸만 후다다닥 해버리는 습관이 아직도 남아있는 것 같다. 다음 주엔 진짜 실수 안할래..! 

------

# BOJ_G5_4811 - 알약

### Idea

- DP

```java
n=0, XX 1
n=1, WH 1
n=2, WHWH WWHH 2
n=3, WHWHWH WHWWHH WWHHWH WWHWHH WWWHHH 5

// n=3을 기준으로 도출된 규칙
n=2일 때를 3-6일에 넣을 수도 있고 2-5일에 넣을 수도 있다.
	3-6일에 넣는 경우, 1-2일에는 선택권이 없으므로 DP[0]*DP[2]의 경우가 된다.
  	2-5일에 넣는 경우, 1, 6일에는 선택권이 없으므로 DP[2]*DP[0]의 경우가 된다.
맨 처음을 W로, 맨 마지막을 H로 고정하고 남는 마지막 경우는 2-3일에 한 알 먹고 4-5일에 한 알 먹는 경우가 있으므로 DP[1]*DP[1]의 경우가 된다.

  => DP[3] = DP[0]*DP[2] + DP[1]*DP[1] + DP[2]*DP[0]
```

### 정리

문제 봤을 때 DP 아니면 못풀겠다는 느낌이 딱 왔다. 알약 1~3개일 때 경우의 수를 다 구했는데 여기서 규칙을 도출하는게 조금 어려웠다. 이리저리 생각해보다가 얼핏 규칙이 떠올라서 그대로 코드 짜서 실행해봤는데 운좋게 통과했다. 다시 분석해보는데 어느 정도는 알 것 같으면서도 완벽하게 이해가 가지는 않아서 좀 아쉽다. 더 자명한 방법이 떠올랐으면 더 좋았을 것 같다.