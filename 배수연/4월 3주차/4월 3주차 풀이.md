# 4월 3주차 풀이

# BOJ_S2_2644 - 촌수계산 👨‍👩‍👧‍👧

### Idea

- 인접리스트를 이용한 그래프 탐색
- 일차원 배열을 통해 각 노드 간 촌수 계산

### 정리

처음에는 인접행렬을 이용해서 탐색하게 했는데 이상하게 자꾸 답이 안나왔다. 그래서 싹 지우고 인접리스트로 다시 구현하니까 바로 답이 나왔다. 

------

# BOJ_S1_2502 - 떡 먹는 호랑이 🐯

### Idea

- DP
- 피보나치 수열
- 첫 요소를 A, 두 번째 요소를 B라고 했을 때 N번째 날의 떡 개수는 다음과 같다.

```java
Day 1 : 1A + 0B
Day 2 : 0A + 1B
Day 3 : 1A + 1B
Day 4 : 1A + 2B
Day 5 : 2A + 3B
Day 6 : 3A + 5B
.
.
.
Day N : (n-1)A+(n-2)A + (n-1)B+(n-2)B
```

* 따라서 N번째 날의 총 떡 개수가 주어졌다면, 해당 날에 맞는 `xA + yB` 수식을 찾고 반복문을 통해 적절한 x, y를 찾으면 된다.
* 답이 여러 개인 경우 아무거나 출력해도 정답이므로 i=0부터 계산해보면서 수식을 만족하면 출력하고 break를 건다.

### 정리

처음에는 DP를 top-down 방식으로 생각해야하는지 고민했다. 그런데 어차피 피보나치 수열이고 첫 요소와 두 번째 요소를 통한 수식으로 표현할 수 있기 때문에 깊게 생각할 필요가 없다고 생각했다. DP의 기초를 묻는 문제에 간단한 수학을 사용하는 문제였던 것 같다.

------

# BOJ_G4_15685 - 드래곤 커브 🐲

### Idea

- 시뮬레이션
- 드래곤 커브의 세대 별 진행 방향은 다음과 같다.

```java
0세대 : 0
1세대 : 0 | 1
2세대 : 0 1 | 2 1
3세대 : 0 1 2 1 | 2 3 2 1
.
.
.
n세대 : (n-1세대 그대로) | (n-1세대 역순으로 +1)
```

- 진행 방향을 미리 리스트에 담아놓는데, 이전 세대의 진행 방향을 그대로 가져오고 역순으로 +1한 값을 붙여준다.
- 출발점으로부터 각 방향으로 이동하면서 map[101][101]의 해당 칸을 true로 저장한다.
- 0~100의 이중 for문을 돌면서 한 칸 기준으로 (자기 자신, 우, 상, 우상) 칸이 모두 true인 경우 ans++

### 정리

처음에 예제를 자세히 안살펴보고 커브가 우상좌하 순으로만 이루어진다고 생각했다. 그래서 단순하게 구현했는데 어림도 없었다. 예제 다시 읽어보면서 방향 전환의 규칙을 생각했는데 조금 오래 걸렸다. 중간을 끊어서 생각하니까 바로 아~ 이거구나 싶었다. 

다 구현하고 첫 번째 테케 돌려봤는데 이상한 값이 나왔다. 진짜 의아해하면서 map의 모든 값을 다 찍어봤는데, 문제에 제공된 힌트랑 다른 모양이어서 엥?? 싶었다. 모양이 너무 달라보여서 하나의 드래곤 커브씩 찍어봤는데 또 맞는것 같아서 진짜 이상하다고 생각했다. 자세히 보니까 (x, y)가 반전된 모양이어서 드래곤 커브를 진행하는 메소드를 dragon(x, y, d, g)로 호출했던거를 `dragon(y, x, d, g)`로 수정했더니 바로 통과했다.