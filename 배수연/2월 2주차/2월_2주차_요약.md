# 2월 2주차 요약

---

# BOJ_S2_2841 - 외계인의 기타연주

### Idea

- Int 배열 형태의 스택 사용
- 6개의 줄로 구성되어 있기 때문에 배열 크기는 0 포함 7로 설정
- 각 줄의 최근 플랫이 새로운 플랫보다 큰 값이면 pop()
- 그 외의 경우에는 push()

### Code

```java
public class BOJ_S2_2841 {
	public static void main(String[] args) throws IOException {
		...		
		Stack<Integer>[] stack = new Stack[7];
		for(int i = 1 ; i<=6 ; i++) {
			stack[i] = new Stack<Integer>();
		}
		...
		for(int n = 0 ; n<N ; n++) {
			while(!stack[L].isEmpty() && stack[L].peek() > F) {
				stack[L].pop();
				cnt++;
			}
			if(stack[L].isEmpty() || stack[L].peek() < F) {
				stack[L].push(F);
				cnt++;
			}
			if(stack[L].peek() == F) continue;
		}
		System.out.println(cnt);
	}
}
```

---

# BOJ_S1_2447 - 별찍기 10

### Idea

- 재귀
- 전체 map을 ' '로 초기화
- 3x3 배열로 생각했을 때, (1, 1) 자리만 비우고 나머지는 '*'로 채워주기
- 주의 사항 : 출력을 System.out.print(map[i][j])로 하면 시간 초과 발생. 이 부분을 생각하지 못하고 재귀 부분에서만 수정했었는데 계속 시간 초과가 생겨서 StringBuilder 사용하니 바로 통과..😢

### Code

```java
public class BOJ_S1_2447 {
	public static void main(String[] args) throws NumberFormatException, IOException {
		...
		map = new char[N][N];
		for(int i = 0 ; i<N ; i++) {
			Arrays.fill(map[i], ' ');
		}
		draw(0, 0, N);
		... (출력)
	}
	
	public static void draw(int r, int c, int idx) {
		if(idx == 1) {
			map[r][c] = '*';
			return;
		}
		for(int i = 0 ; i<3 ; i++) {
			for(int j = 0 ; j<3 ; j++) {
				if(i == 1 && j == 1) continue;
				else draw(r+i*idx/3, c+j*idx/3, idx/3);
			}
		}
	}
}
```

---

# BOJ_S5_1018 - 체스판 다시 칠하기

### Idea

- 'W'로 시작하는 8x8 배열과 'B'로 시작하는 8x8 배열을 미리 선언해두기
- 입력 받은 map과 미리 선언된 white_chess, black_chess와 한 칸씩 비교하며 바꿔야 하는 칸 개수 세기
- 바꿔야 하는 칸 개수 중 최솟값 구하기

### Code

```java
public class BOJ_S5_1018 {
	static int N, M;
	static char[][] map;
	static char[][] white_chess = {
			{'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
			{'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
			{'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
			{'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
			{'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
			{'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
			{'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
			{'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'}
	};
	static char[][] black_chess = {
			{'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
			{'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
			{'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
			{'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
			{'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
			{'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'},
			{'B', 'W', 'B', 'W', 'B', 'W', 'B', 'W'},
			{'W', 'B', 'W', 'B', 'W', 'B', 'W', 'B'}
	};

	public static void main(String[] args) throws IOException {
		...
		for(int i = 0 ; i<=N-8 ; i++) {
			for(int j = 0 ; j<=M-8 ; j++) {
				int white_cnt = 0;
				int black_cnt = 0;
				for(int x = i ; x<i+8 ; x++) {
					for(int y = j ; y<j+8 ; y++) {
						if(map[x][y] != white_chess[x-i][y-j]) white_cnt++;
						if(map[x][y] != black_chess[x-i][y-j]) black_cnt++;
					}
				}
				int temp_min = Math.min(white_cnt, black_cnt);
				min = Math.min(min, temp_min);
			}
		}
		System.out.println(min);
	}
}
```

---

## 총평

기타 연주는 금방 해결했고 체스판도 좌표 계산 잘못해서 시간 좀 소비한 거 빼면 나쁘진 않았던 것 같다.

체스판 문제 다시 생각해보면 지금 방식이 은근 노가다여서 i+j 짝수인 칸 홀수인 칸 나눠서 비교해보면 조금 더 똘똘한 코드가 되지 않을까 싶다.

문제는 별찍기.. 재귀인거 알았고 규칙도 금방 도출했는데 시간 초과의 늪에서 나올 수가 없었다. 처음에 입력 Scanner로 받고 출력은 System.out.print로 해서 시간 초과 뜨길래 입력만 바꿔줘야지~ 하고 BufferedReader로 바꿔줬는데도 계속 시간 초과가 나는 것......... 재귀 함수도 조금씩 수정했는데도 안되길래 혹시 몰라서 StringBuilder로 출력해봤는데 바로 통과.... 진짜 허무했지만 시간 초과 나면 바로 입출력부터 바꿔보고 생각하자는 교훈을 얻었다.