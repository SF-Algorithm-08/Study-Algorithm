# 4월 4주차 풀이

# BOJ_G4_4386 - 별자리 만들기🌌

### Idea

- 그래프 - Kruskal
- Union Find

### 정리

Kruskal 알고리즘의 정석같은 문제였는데 아직 kruskal/prim 문제는 능력 부족이어서 혼자 힘으로는 해결하지 못했다. 유튜브 수업때 짰던 교과서 코드 보면서 문제에 맞게 응용했는데 살짝 감이 오는 것 같다. 몇 번 더 연습해보면 혼자 힘으로도 풀 수 있을 것 같다. 화이팅👊

------

# BOJ_G4_1043 - 거짓말🤥

### Idea

- 그래프 + DFS
- 인접리스트
- 전체 인원 중 비밀을 아는 사람을 `true`로 처리
- ArrayList<Integer>[]로 파티마다 오는 사람 정보를 저장
- 한 파티에 2명 이상 방문하는 경우는 서로 연결됐다고 양방향으로 `true` 처리
- 모든 정보를 입력받은 이후에, 비밀을 아는 사람에 대해서 DFS 실행

### 정리

입력받는 게 많아서 생각하기에 조금 복잡했다. 진실을 아는 사람 수가 0일 때나 파티에 오는 사람이 한 명일 때 따로 처리를 해야 하는데 그걸 생각하는게 좀 어려웠다. 개인적으로는 세 문제 중에 제일 어려웠다! 그래도 차근차근 처리하니까 해결하긴 했다. 알고리즘 분류에 '분리집합' 있는걸 보면 유니온파인드로도 해결할 수 있는 문제인건가? 싶다.

------

# BOJ_G2_1938 - 통나무 옮기기🌲

### Idea

- BFS + 시뮬레이션
- 출발지의 통나무의 중심점과 가로/세로 방향 정보를 BFS 탐색의 시작으로 저장
- 목적지의 중심점과 가로/세로 방향 정보를 저장
- 가로/세로 방향은 0과 1로 구분
- UDLR은 일반 4방탐색과 유사
  - 방향이 가로일 때는 왼쪽 오른쪽도 map 범위 내에 있는지와 이동 가능한지 판단
  - 방향이 세로일 때는 위쪽 아래쪽도 map 범위 내에 있는지와 이동 가능한지 판단
- T는 주변 3*3이 비어있어야 하기 때문에 8방탐색
  - boolean형의 `canRotate`를 `true`로 초기화하고, 주변 8방 중 조건에 부합하지 않으면 `false`로 바꿔주기

### 정리

조건이 까다로워서 생각할게 많았다. 그래도 시뮬레이션이라서 주석으로 설계부터 쭉 짰더니 통과할 수 있었다. 그리고 지난 번에 BFS에서 횟수를 따지는 문제에서 queue에 횟수 인자를 갖고 반복하지 않고, while 반복을 돌 때마다 횟수를 체크했더니 한참 해결 못했던 실수가 있었다. 이 기억으로 이번엔 queue에 횟수 인자를 갖고 돌려서 바로 통과할 수 있었다. 

시뮬레이션 문제는 철저한 설계로부터 시작해야 한다는거 꼭 기억해둬야겠다.