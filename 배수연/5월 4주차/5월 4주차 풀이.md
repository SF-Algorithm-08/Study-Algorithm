# 5월 4주차 풀이

# BOJ_S1_16918 - 봄버맨💣

### Idea

- 시뮬레이션

- 0초부터 각 초에 무슨 일이 일어나는지 판단해보기

  ```java
  0초 : 초기 상태
  1초 : X
  2초 : 폭탄 없는 곳에 폭탄 설치
  3초 : 0초 폭탄 폭발
  4초 : 폭탄 없는 곳에 폭탄 설치
  5초 : 2초 폭탄 폭발
  6초 : 폭탄 없는 곳에 폭탄 설치
  7초 : 4초 폭탄 폭발
  ...
  => 2초부터 짝수 초에 폭탄 설치, 홀수 초에 3초 전 폭탄 폭발
  ```

- 격자판의 상태를 저장할 `map` 배열과 각 칸의 폭탄이 몇 초에 터질 것인지를 저장할 `explode` 배열 선언

### Code

``` java
1. 입력받은 초기 map에서 폭탄이 있는 곳을 찾고 explode 배열에 3 저장 (처음에 폭탄이 있던 곳은 3초에 폭발)
2. while문 반복하면서 time++시켜주기
  2-1. time == N+1이 되면 break
  2-2. 짝수 초에는 폭탄 설치
    2-2-1. 이중포문 돌면서 폭탄이 없는 곳 찾기
    2-2-2. map 배열에 폭탄 넣어주기
    2-2-3. explode 배열에 3초 뒤에 폭발한다고 저장
  2-3. 홀수 초에는 폭탄 터뜨리기
    2-3-1. 이중포문 돌면서 explode 배열값이 현재 시간과 같은 곳 찾기
    2-3-2. map 배열에서 그 좌표랑 상하좌우 좌표를 '.'으로 만들기
    2-3-3. explode 배열값을 0으로 바꾸기
```

### 정리

처음에 문제를 읽고 무슨 소리지?? 싶었다. [1초 쉬기-폭탄설치-폭발]로 잘못 생각해서 엥 그럼 반복을 어떻게 해줘야 하지?? 싶었는데 문제를 다시 읽으면서 각 초별로 무슨 일이 발생하는지 정리해보니까 감이 왔다. 몇 초 뒤에 폭탄 터지는걸 어떻게 판별하나 고민했는데, 어차피 연쇄 반응이 없다고 했으니까 설치된 시간을 이용해서 저장하면 되겠다고 생각했다.

BFS나 DFS를 사용하지 않고 단순하게 풀이한 것 같다.

------

# BOJ_G4_2482 - 색상환🎨

### Idea

- DP
- 원형으로 색상이 구성되어 있고 색 하나를 고르면 양 옆 2개는 고를 수 없다.
- 선형으로 생각한 뒤, 원의 시작점이 되는 하나를 선택한 경우와 선택하지 않은 경우로 구분
- (선형)
   * K=0, 1
   * K=1, N
   * K>=1, N번째 색을 고르는 경우 / 안고르는 경우
      * N번째 색을 고르는 경우 : N-2개에서 K-1개 고른 경우
       * N번째 색을 고르지 않는 경우 : N-1개에서 K개 고른 경우
 - (원형)
    * 원의 시작점을 고른 경우 / 안고른 경우
       * 고른 경우 : N-3개에서 K-1개 고른 경우
        * 안고른 경우 : N-1개에서 K개 고른 경우

### Code

```java
long[][] DP = new long[N+1][K+1];
for(int n = 1 ; n<=N ; n++) {
	// K=0일 때, 1가지 경우만 존재
	DP[n][0] = 1;
	// K=1일 때, N번째 색을 고르는 경우는 N
	DP[n][1] = n;
}
for(int n = 2 ; n<=N ; n++) {
	for(int k = 2 ; k<=K ; k++) {
		DP[n][k] = (DP[n-2][k-1]+DP[n-1][k])%MOD;
	}
}
System.out.println((DP[N-3][K-1]+DP[N-1][K])%MOD);
```

### 정리

DP 문제를 꽤 오랜만에 풀어서 열심히 고민했다. 처음에는 3차원 배열로 선언해서 [N번째 색][선택/미선택][K개의 색 선택] 으로 구성했는데 예제는 맞았지만 제출하자마자 틀렸다고 나왔다. 그래서 질문 게시판 둘러보다가 선형으로 생각하고 원형으로 묶으라는 글을 보고 2차원 배열로 다시 선언했다. 점화식에서 좀 고민했지만 그래도 통과!

------

# BOJ_G4_1918 - 후위표기식🔙

### Idea

- 문자열, 스택
- 문자열 한 칸씩 판단하면서
  - 문자열이면 정답에 붙여주기
  - 여는 괄호면 스택에 넣어주기
  - `*`, `/`면 스택의 꼭대기에 같은 우선순위인 `*`, `/`인 동안 정답에 pop()붙여주기, 이후에 스택에 넣기
  - `+`, `-` ,`)`면 스택이 비거나 `(` 나올 때까지 정답에 pop()붙여주기, 이후에 `+`, `-`면 스택에 넣어주고 `)`면 스택 맨 위에 있는 `(` 빼주기
  - 스택에 남아있는 것들 정답에 쭉 붙여주기

### Code

```java
for(int i = 0 ; i<line.length() ; i++) {
	char temp = line.charAt(i);
	if('A'<=temp && temp<='Z') ans += temp;
	else if(temp == '(') stack.push(temp);
	else if(temp == '*' || temp == '/') {
		while(!stack.isEmpty() && (stack.peek() == '*' || stack.peek() == '/')) {
			ans += stack.pop();
		}
		stack.push(temp);
	}
	else if(temp == '+' || temp == '-' || temp == ')') {
		while(!stack.isEmpty() && stack.peek() != '(') {
			ans += stack.pop();
		}
		if(temp == '+' || temp == '-') stack.push(temp);
		else stack.pop();
	}
}
while(!stack.isEmpty()) ans += stack.pop();
```

### 정리

스택을 이용한 후위 연산자 표기법의 대표적인 문제이다. 후위 연산자가 스택 이용한다는 걸 알고 있어서 그런지 G4까지는 아닌 것 같다.