# 4월 5주차 풀이

# BOJ_G4_2616 - 소형기관차🚂

### Idea

- DP

- 각 객차에 타고 있는 손님 수를 입력받을 때, 각각의 값을 그대로 입력받지 말고 이전 칸의 승객 수에 누적해서 값을 받아준다. => 소형기관차의 승객 수를 계산할 연산 수 감소

- DP[소형 기관차 개수 + 1][원래 열차 + 1] 크기로 배열 선언

- DP 배열 저장 수식은 다음과 같다.

  ```java
  for(int i = 1 ; i<=3 ; i++) {
  	// i번째 소형기관차는 무조건 i*(소형기관차 길이)부터만 탐색 가능
  	for(int j = i*littleTrain ; j<=bigTrain ; j++) { 
  		// j기준 이전 M칸의 인원 : arr[j]-arr[j-littleTrain]
  		//		    현재 열차 미포함	 j-소형 ~ j번째 기차 + 이전 소형기관차가 끄는 최대
  		DP[i][j] = Math.max(DP[i][j-1], (arr[j]-arr[j-littleTrain])+DP[i-1][j-littleTrain]);
  	}
  }
  ```

  ```java
  // 예제 [35 40 50 10 30 45 60] 실행 시 
  // 입력 배열 저장 결과
  [0, 35, 75, 125, 135, 165, 210, 270]
  // DP배열 저장 결과
  [0, 0, 0, 0, 0, 0, 0, 0]
  [0, 0, 75, 90, 90, 90, 90, 105]
  [0, 0, 0, 0, 135, 135, 165, 195]
  [0, 0, 0, 0, 0, 0, 210, 240]
  ```

### 정리

수식을 생각하는데 꽤 시간이 걸렸다. 그림을 그리면서 고민하니 조금 실마리가 보였다. DP는 오랜만에 풀어서 또 배열 선언할 때 실수를 할 뻔 했다. 한 칸씩 크게 선언해야 하는거 잊지 말자!!

------

# BOJ_G0_1344 - 축구⚽

### Idea

- 90분의 게임을 5분씩 분할하여 18간격으로 생각하기

- 각 팀이 승리할 확률이 주어지기 때문에, 조합으로 승리할 횟수를 정해두면 그 횟수에 맞게 전체 게임에서 승리할 확률을 구할 수 있다.

- "적어도 한 팀이 승리할 확률"을 구해야 하기 때문에 각각 A가 승리할 확률, B가 승리할 확률을 구하면 (A승리확률)+(B승리확률)-(A승리확률)*(B승리확률)로 구하면 된다.

- 전체 18게임 중 소수로 득점할 수 있는 경우는 [2, 3, 5, 7, 11, 13, 17]로 7경우이다.

- 조합(파스칼의 삼각형) : nCr = n-1Cr-1 + n-1Cr

  ```java
  for(int i = 0 ; i<19 ; i++) {
  	for(int j = 0 ; j<=i ; j++) {
  		if(i == j || j == 0) DP[i][j] = 1;
  		else DP[i][j] = DP[i-1][j-1] + DP[i-1][j];
  	}
  }
  ```

- 두 플레이어가 게임을 할 때 r번 승리할 확률 : nCr * (승리확률)^r * (1-승리확률)^(n-r)

  ```java
  double sumA = 0.0, sumB = 0.0;
  for(int i = 0 ; i<7 ; i++) {
  	sumA += DP[18][score[i]] * Math.pow(A, score[i]) * Math.pow(1-A, 18-score[i]);
  	sumB += DP[18][score[i]] * Math.pow(B, score[i]) * Math.pow(1-B, 18-score[i]);
  }
  ```

### 정리

처음에는 조금 당황했지만 게임에서 r번 승리할 확률을 구하는 공식을 떠올리고 나서 수학적인 문제라고 생각하게 됐다. 파스칼의 삼각형을 집적 구현해본 적은 없는 것 같은데 차근차근 생각하면서 구현하니까 단순하게 구현할 수 있었다. Computational Thinking이랑 연관지어서 풀 수 있어서 좋았다~!

------

# BOJ_G0_17825 - 주사위 윷놀이🎲

### Idea

##### 첫 번째 아이디어 - 실패

- 갈 수 있는 노선을 *전부* 저장

  ```java
  [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40]
  [0, 2, 4, 6, 8, 10, 13, 16, 19, 25, 30, 35, 40]
  [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 25, 30, 35, 40]
  [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 28, 27, 26, 25, 30, 35, 40]
  ```

- 움직이는 말들을 조합하는 방법 : 10TT4

- 다른 말이 같은 위치에 있게 되는 경우를 if-else로 전부 구분해줌

- 잘못 생각한 부분1 : 주사위 값을 더하게 되면 말이 위치한 칸의 값이 아니라 말이 위치한 칸의 인덱스가 변화하는 건데, 값이 바뀐다고 잘못 생각했다.

- 잘못 생각한 부분2 : 아마도 모든 노선의 시작점에 0을 넣어서 계산이 잘못된 방향으로 흘렀을 가능성이 있다.

##### 두 번째 아이디어 - 성공

- 파란색 화살표로 나뉘는 경우와 노선을 따로따로 구분하여 저장

  ```java
  [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38]
  [13, 16, 19]
  [22, 24]
  [28, 27, 26]
  [25, 30, 35]
  [40]
  ```

- 움직이는 말들을 조합하는 방법 : 10TT4 (동일)

- 말 위치 인덱스는 모두 -1로 초기화 (출발하지 않은 경우도 구분해야 하기 때문)

- 라인에 맞게 말을 움직이다가 파란 화살표로 나가게 되는 경우(10, 20, 30에서 출발)는 if-else로 구분해주기

- 턴마다 주사위 값을 for문으로 1씩 더해주면서 노선을 변경해야 하는 경우면 line을 바꿔주고 말 위치 인덱스를 0으로 바꿔준다.

- 도착지에 도달한 경우는 line을 -1로 지정해서 중복검사 안하도록 continue

- 중복 검사는 말의 line 번호와 인덱스 위치가 같은지로 판단

- 말의 진행이 가능한 경우(중복X)에는 주사위에 따라 말 위치 인덱스와 진행 라인을 갱신시켜주고, 전체 sum에 더해준다. 

- **(중요)** 중복에서 걸려서 말의 진행이 불가능하다면 해당 말의 조합(nTTr)을 더이상 판단하지 않아도 된다 => return해주기

### 정리

진짜 어려웠다.. 문제 처음 봤을 때에는 어떻게 구현해야 할지 엄청 막막했다.

하루 정도는 고민하고 첫 번째 아이디어로 한 세 시간 정도 짰는데 실패해서 그냥 노트북 접고 조금 더 고민을 했다. 그래서 다음 날 다시 새롭게 다른 아이디어로 짜니까 조금 진전이 있었다.

이번 주의 실수... 가장 긴 길로 돌아가는 경우를 [2~38]로 넣어야 하는데, 맨 앞에 0도 넣었다... 자꾸 테케를 돌릴 때 2씩 작은 값이 나와서 너무 화가 났는데 생각지도 못한 곳에 실수가 있었다..😢 이 부분을 수정해서 제출했는데 29%정도에서 틀렸습니다가 떠서 질문 검색 란에서 찾아보니까 말이 중복되는 경우에는 다음 조합으로 넘어가게 해야 한다는 글을 발견했다. 그래서 그 부분 추가해줬더니 바로 통과했다. 

G2 시뮬레이션은 너무 복잡해...