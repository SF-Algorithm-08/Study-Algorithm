3월 2주차 문제 정리

-------------------------------------------------------------------------------------------------------------------------------------------------
#백준 G3 2143 두 배열의 합
○Idea
 - 두 배열의 부배열들의 집합에서 원소들의 합이 T인 갯수를 찾는 문제
 - N,M이 1000까지이므로 각각의 부배열로 만들 수 있는 합배열을 이중for문으로 구하기 O(n^2)
 - 합배열 a에서 합배열 T-bSum[]과 같은 값의 갯수를 구하기
 - 이중for문으로 구하면 1000의 4승이므로 시간 초과
 - a를 정렬시키고 이분탐색으로 해당 값의 시작 index와 끝 index를 구해서 갯수 세기 O(logn)

●평가
 - 이분탐색 문제라는 것을 알고 푼 문제였는데 해결하는데 상당히 오래 걸렸다. 
 - 시작점과 끝점을 한번에 구해보려다가 실패했는데 아직 이분탐색 구현이 익숙하지 않아 반복적으로 연습해야겠다.

-------------------------------------------------------------------------------------------------------------------------------------------------
#백준 G4 6087 레이저 통신
○Idea
 - 통신을 하는 두 지점을 이어주는 최소로 거울을 놓는(방향을 꺾는) 횟수를 구하는 문제
 - bfs로 queue에 한 지점의 좌표를 넣어주고 4방향으로 진행시키는데 벽이나 board 밖으로 나가기 전까지 진행
 - 진행하면서 방문한 좌표는 현재 좌표로 오기까지 꺾은 횟수에 +1을 dist[][]에 저장 (4방향 진행)
 - 나머지 지점에 도착했을때 해당 좌표의 dist값을 출력

●평가
 - 처음에는 queue의 템플릿으로 좌표뿐만 아니라 좌표로 들어올때 방향과 꺾은 횟수를 같이 넣어주고 방문 처리를 boolean으로 해줬다.
 - 그러나 일반적이 그래프탐색과 달리 재방문을 했을 경우 더 최소가 되는 경우가 존재했다.
 - while문에서 4방향 탐색을 한번씩 하는 것은 트리 구조에서는 같은 depth지만 순서가 존재하므로 dist배열을 만들어 최소값으로 갱신했는데
 - 4방향 진행에서 같으면  출력 결과로 dist배열에는 모든 최솟값이 저장되었지만 메모리 초과가 발생
 - 해결방법을 한참을 고민했는데 4방향 진행에서 반복문을 추가해 직선상의 좌표들을 같은 값으로 갱신하는 것으로 해결했다.

-------------------------------------------------------------------------------------------------------------------------------------------------
#백준 S1 14715 전생했더니 슬라임 연구자였던 건에 대하여 (Easy)
○Idea
 - 슬라임을 두 수의 곱으로 쪼개면서 더 쪼개지지 않을 때까지 쪼갰을 때 흠집(tree의 depth)를 구하는 문제
 - 입력값 K를 소인수분해하면서 최대한 고르게 분배했을 때 depth가 최소
 - K를 2~K까지 나누어 떨어지는 수가 있을 때 cnt++ 후 K를 해당 수로 나누고 break, 아직 더 분해 할 수 있으면 다시 2부터 시작 K가 1이되면 종료
 - depth >= 2^cnt인 depth를 answer로 출력  

●평가
 - 어떤 경우가 가장 최소일까 그려보니 포화트리에 가까울때 깊이가 최소가 나왔다.
 - cnt를 구하는건 쉬웠는데 depth를 어떻게 구할까 고민하다가 비트연산으로 1을 한칸씩 왼쪽으로 시프트하다가 cnt를 넘는 순간의 횟수를 답으로 구했다. 