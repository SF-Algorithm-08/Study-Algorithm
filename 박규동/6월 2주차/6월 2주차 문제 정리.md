# 6월 2주차 문제 정리

# 백준 G4 1963 소수 경로 

### ○Idea

- 소수인 이전 비밀번호와 바꿀 비밀번호가 입력으로 주어지고 한번에 한자리만 바꿔서 소수인 수를 만들 때 몇 번의 이동으로 바꿀 수 있는지 출력하는 문제
- 4자리 비밀번호이므로 10000이하의 소수를 모두 담고 있는 set을 구현
- 이전 비밀번호와 바꾼 횟수를 담아 bfs로 순회
- 방문체크를 하면서 해당 비밀번호에 도달 시 cnt를 리턴

### ●평가

- 문제의 구현 로직 자체는 어렵지 않았고 발상도 금방 떠올랐지만 소수를 찾는 효율적인 알고리즘이 낯설어 조금 고민했다.
- 소수를 찾는 알고리즘은 에라토스테네스의 체를 활용하여 담았다.
- 수를 문자열로 저장하고 다시 변환하는 비효율적인 방법으로 구했는데 스터디원들이 문자열을 빌더로 직접 바꾸는 방식을 추천했다.

------

# 백준 G2 1561 놀이공원

### ○Idea

- N명의 아이들과 M개의 놀이기구, 각 놀이기구마다 한 명이 타는데 걸리는 시간이 입력으로 주어지고 N번째 아이가 타는 놀이기구를 출력하는 문제
- N이 20억이고 시간이 30까지라 최대 600억분의 시간을 잡고 풀었다.
- 마지막 아이가 타는 시간을 알기 위해 이분탐색으로 시간을 구하고 이전 시간과 타는 시간에서 나누어 떨어지지 않는(아직 타고있는) 수마다 ++를 시켜주고 N에 도달 시 인덱스+1(놀이기구 번호)을 리턴

### ●평가

- 이분탐색에서 시간을 잡고 푸는 방식은 맞았지만 각각 letf, right, mid가 의미하는 것이 무엇인지 알고 푸는게 중요했다.
- 이 문제뿐만 아니라 이분탐색에서 mid와 비교하는 것이 무엇인지 return이 무엇인지 자주 헷갈리는데 정확히 논리를 이해하자

------

# 백준 G5 14520 연구소

### ○Idea

- 격자가 주어지고 각 격자는 빈 칸, 벽, 바이러스로 구성되어 있을 때, 3개의 벽을 설치해서 생성할 수 있는 안전영역의 최댓값을 구하는 문제
- copymap을 통해 벽을 Combination으로 3개 설치한 경우를 기저조건으로 bfs를 수행
- 안전영역의 갯수를 세고 최대값을 갱신

### ●평가

- 전형적인 bfs문제
- 원본을 변형시키는 것이 문제 될까 싶어서 copymap을 만들었는데 벽을 세운 곳을 어차피 다시 돌려줘야 하니 굳이 그럴필요는 없을 것 같다.
------