# 5월 1주차 연습
## 1. 백준 G4 17298 오큰수 
### 문제 정의
1. 크기가 N인 수열이 있을 때 원소 Ai의 오른쪽에 있으면서 Ai보다 큰 수 중에 가장 왼쪽에 있는 수를 출력하라.
2. 1 ≤ N ≤ 1,000,000, 1 ≤ A ≤ 1,000,000

### 문제 풀이
1. arr[N]: 수열을 입력받을 배열, result[N]: 오큰수를 저장할 배열
2. 수열의 끝에부터 오큰수를 stack에 저장하며 탐색한다.
3. Stack에 arr[N-1]을 push하고 result[N-1] = -1 저장
4. N-2부터 0까지 반복문으로 탐색
    1. stack.peek이 원소보다 크면 오큰수이므로 result에 저장
    2. 원소가 stack.peek보다 크거나 같으면 오큰수를 만날때까지 stack을 pop
    3. 만약 stack이 비었으면 오큰수가 없으므로 result에 -1을 저장
    4. 아니면 stack.peek을 result에 저장
    5. 현재 원소를 다음 탐색을 위해 stack에 push한다.
5. 주의! N이 백만이므로 reult를 출력할 때 stringbuilder로 출력

### 정리
정올의 불행한 날과 비슷한 문제였다. 전에 라인 문제 중에 오큰수와 비슷한 문제가 있어서 문제를 추가한건데 라인보다 훨씬 쉬웠던 것 같다..그리고 처음에 반복문을 돌면서 결과를 출력했더니 시간초과가 떠서 stringBuidler를 쓰니까 통과됐다. N이 커질 때는 무조건 StringBuilder로 출력하자


## 2. 백준 G4 1774 우주신과의 교감
### 문제 정의
1. 황선자와 우주신들을 모두 연결할 때(MST를 만들 때) 최소 길이를 구하라
2. 황선자, 우주신들의 좌표 N개가 입력되고, 미리 연결되어 있는 통로가 N개 주어진다.
3. 1≤ N, M ≤ 1000

### 문제 풀이
1. MST를 구하는 문제인데 노드 개수가 1000개, 간선 개수가 1,000,000만개이므로 간만프로 프림이 좋다. 벗 나는 크루스칼로 품
2. root[N+1] :  열결된 부모 노드 저장, Edge{from, to, weight}: 간선 클래스
3. N개의 좌표를 받아서 각각 x 좌표, y 좌표 저장. 이중 반복문으로 모든 좌표끼리의 간선의 거리를 구해서 PriorityQueue에 저장한다.
4. PriorityQueue는 간선(Edge)의 weight가 작은 애들이 앞에 위치한다.
5. 미리 연결된 M개의 인덱스들은 미리 union 해준다.
6. pq에 있는 N-1개의 간선을 뽑아서 union해주고 그 때의 weight를 결과값에 더해준다.

### 정리
프림이 더 효과적일 것 같은 문제였지만 크루스칼을 안 쓴지 오래돼서 크루스칼로 풀었다. swea의 하나로와 매우 비슷한 문제였다. 

----
# 5월 2주차 풀이
## 1. 백준 G5 1089 스타트링크 타워
### 문제 정의
1. 숫자 1개를 표현하기 위해 가로 3, 세로 5가 필요하다. 
2. N이 주어질 때 일부 칸이 가려져서 보이지 않는다. 가능한 모든 숫자들의 평균을 출력하시오. 가능한 번호가 없을 경우 -1 출력
3. 1 ≤ N ≤ 9

### 문제 풀이
1. 1~9까지 수를 3차원 char 배열에 미리 저장한다.
2. 입력받은 수를 2차원 char 배열에 저장한다. 입력의 열을 0~3, 4~6씩 끊어가며 각 자리를 1~9까지 모두 비교해서 그 수가 될 수 있는지 체크한다.
3. List<Integer> nums[] 리스트 배열을 만들어서 각 자리별로 가능한 수를 저장한다.
4. 리스트별로 돌면서 각 자리수가 가능한 값을 모두 더하고, 해당 자리수(1 → 10 → 100)을 곱한 값을 리스트 배열의 개수만큼 나눠서 해당 자리의 평균을 구한다.
5. 4번 과정을 모든 자리수에서 평균을 구해주고 결과에 더해준다.
```java
static double findSum() {
    double avg = 0f;
    int mul = 1;
    
    for(int i = N-1; i >= 0; i--, mul *= 10) {	//끝자리(1의자리)부터 더해준다. 
        long sum = 0;	//99999999까지므로 long형 안하면 오버플로우 
        int cnt = 0;
        for(int j = 0, len = nums[i].size(); j < len; j++) {
            sum += nums[i].get(j) * mul;
            cnt++;
        } 
        if(cnt == 0) 	return 0;		//만약 중간 자리가 가능한 수가 없다면 -1 출력 
        avg += sum / (double)cnt;		// 각 자리수에서 더한 값에 mul 곱해주고, 평균 내주기.   		
    }
    return avg;
}
```

### 정리
자리수에서 가능한 수를 구하는 것까진 어렵지 않았는데 평균을 구하는게 어려웠다. 처음엔 dfs로 모든 경우의 수를 조합으로 구해서 더해줬는데 당연하지만 시간초과가 났다. 고민하다가 각 자리별로 리스트 배열에 있는 수의 평균을 자리수만큼 곱해주고 그걸 더하면 평균이 나오는 것을 깨달았다. 그리고 중간 자리가 불가능한 수가 나오면 뒤에 가능하다 해도 -1을 출력해야 하는데 이 점을 간과해서 푸는데 오래 걸렸다.


## 2. 백준 G5 1756 피자굽기
### 문제 정의
1. 오븐의 깊이에 따라 지름이 다르다. 피자 반죽이 완성되는 순서대로 오븐의 위에서부터 들어갈 때 맨 위의 피자 깊이를 구하시오. 만약 피자가 모두 오븐에 들어가지 않는다면 0 출력
2. 1 ≤ D(오븐의 깊이), N(피자 반죽 개수) ≤ 300,000

### 문제 풀이
1. 피자, 오븐의 깊이를 입력받는다. 어차피 피자는 위에서부터 들어가기 때문에 깊은 오븐의 반지름이 넓어도 위에가 좁으면 위에서 걸린다. 오븐이(5, 6, 4, 3, 6, 2, 3)이면 (5, 5, 4, 3, 3, 2, 2)로 내림차순으로 입력을 받는다.
2. 오븐의 맨 끝에서부터 첫번째 피자를 탐색
3. 만약 피자가 오븐보다 크면 들어갈 수 없으므로 다음 오븐 탐색
4. 만약 피자가 오븐보다 작거나 같으면 들어갈 수 있으므로 depth를 현재 오븐 깊이로 갱신, 다음 피자를 탐색하기 위해 피자인덱스 + 1
5. 만약 오븐 탐색 중 피자를 전부 탐색했다면 오븐에 피자를 넣을 수 있으므로 return depth
6. 오븐 탐색이 끝났는데도 리턴이 안됐으면 오븐에 들어갈 수 없는 피자가 있다는 뜻이므로 return 0

### 정리
오븐이 내림차순 정렬이 된다는 아이디어를 떠올리기 힘들었다. 가닥이 잡히니 쉽게 풀 수 있었다.

## 3. 백준 G4 1593 문자해독
### 문제 정의
1. S 문자열 안에 W 단어가 순서 상관없이 부분 문자열로 구성되어 있다. 
2. W 단어가 나타날 수 있는 형태의 가지수를 출력하시오
3. 1 ≤ W ≤ 3000, W ≤ S ≤ 3,000,000

### 문제 풀이
1. 슬라이딩 윈도우
2. 미리 W 단어에 사용된 알파벳을 배열에 기록한다. 배열 A~z(65~122). 
3. 슬라이딩 윈도우로 S문자열을 처음부터 한칸씩 이동하며 윈도우에 사용된 알파뱃의 개수를 기록한다.
4. S가 W길이와 같아지면 두 문자열의 배열이 같은지 확인. 같으면 정답++
5. 그 다음 S의 앞을 제거, 뒤를 붙여주는 식으로 한 칸 뒤로 이동한다.

```java
 // 미리 W단어에 사용된 문자수 카운팅 
for(int i = 0; i < wlen; i++) {
    int alpha = W.charAt(i) - 65;
    w_used[alpha]++;
}

int ans = 0;
int len = 0;			//윈도우에서 W와 알파벳과 동일한 개수 
for(int i = 0; i < slen; i++) {
    s_used[S.charAt(i) - 65]++;	//윈도우 뒤에 추가 
    len++;
    if(len == wlen) {	// S의 부분수열이 W의 길이와 같아질 때 비교 
        if(Arrays.equals(w_used, s_used)) {	//S의 부분수열에서 사용된 알파벳이 W에서 사용된 알파벳과 동일해질때  
            ans++;
        }
        s_used[S.charAt(i-wlen+1)-65]--;	//윈도우 앞을 제거 
        len--;
    }
}
```

### 정리
슬라이딩 윈도우의 핵심은 수열의 길이만큼만 반복하며 O(N) 시간 안에 연산을 끝내는 것이기 때문에 반복문을 안쓰고 S의 부분단어와 W가 같은지 체크해야 했다. 처음엔 HashMap을 쓸까 했는데 그러면 W 길이만큼 또 반복문을 써야 하므로 시간초과가 날 것 같았다. 결국 배열을 통으로 비교한다는 무식한 방법을 쓰긴 했는데 만약 알파벳을 이용한 정수 키값을 만들 수 있다면 더 효율적일 것 같다.