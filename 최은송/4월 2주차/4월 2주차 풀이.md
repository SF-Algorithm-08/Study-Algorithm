## 4월 2주차 풀이 
---
## 1. BOJ G5 4811 알약
### **문제 정의**
1. 약 N개 담긴 병, 한조각 먹으면 W, 반조각 먹으면 H
2. 2N일동안 먹을 때 출력할 수 있는 문자열 개수
3. 1≤ N ≤ 30

### **문제 풀이**
1. long dp[][] = [31][31]을 만든다. 일차원은 알약 1개(one), 이차원은 알약 반개(half)
2. 재귀적으로 one과 half를 먹었을 때의 결과를 dp 배열에 담았다.
3. 기저 조건으로 one이 0일때 half만 남았다는 뜻이니 그 결과 문자열의 경우는 1개밖에 되지 않는다.
4. one을 먹었을 때의 결과를 dp[one][half]에 저장한다.
5. half를 먹었을 때의 결과를 dp[one][half]에 저장한다.

### **정리**
dp를 풀면서 배열의 의미를 찾는게 너무 힘든 것 같다. 그리고 이번 경우는 기저조건을 찾기가 굉장히 까다로웠다.

---
## 2. BOJ G5 2589 보물섬
### **문제 정의**
1. 육지 L, 바다 W일 때 보물은 육지간에 최단 거리로 이동할 때 있어서 가장 긴 시간이 걸리는 곳에 묻혀 있다.
2. 육지는 상하좌우로 이동가능하며 한칸 이동하는데 1시간 걸린다.
3. 최단거리 출력

### **문제 풀이**
1. 이중 for문을 돌면서 육지를 만나면 bfs를 실행해 최단거리의 최대값을 구한다.
2. bfs에서 최단거리를 구하기 위해 Queue의 사이즈만큼 반복하며 육지를 큐에 넣고 level을 1 증가시킨다.

### **정리**
보충때 교수님이 bfs 최단거리를 구하는 방법으로 큐를 레벨별로 원소를 찾아서 넣는 방법을 말씀해주셨다. 응용해서 사용하는 것은 처음인데 효과적인 방법인 것 같다.

---
## 3. BOJ S2 5525 IOIOI
### **문제 정의**
1. N = 1 P1 = IOI, N=2 p2 = IOIOI...일때 문자열 S에서 P가 몇개나 포함됐는지 개수를 찾으시오

### **문제 풀이**
#### 아이디어 1
1. 문자열 s에 대해 p를 하나씩 전부 대조하는 방법
- s, p가 1,000,000까지이기 때문에 시간초과

#### 아이디어 2
1. P가 IOI가 반복되는 패턴을 이용해 문자열 s에 대해서만 반복문을 돌며 IOI가 몇 개 있는지 세주는 방법
2. 만약 s.substring(i, i+3) == "IOI"이면 pn을 1 늘려준다.
3. pn == N이면 cnt++해주고 pn -=1, i += 2해준다. 
- pn을 1 줄여야 하는 이유는 p가 IOIOI이고 s가 IOIOIOIOO일 때  처음 패턴에서 IOIOI를 체크해주고 i가 2부터 다음 IOI를 체크함. 그때 앞의 IOI의 개수를 누적해야 하므로 pn을 1 줄여준다.

### **정리**
S2주제에 제일 어려웠던 것 같았다. s,p의 범위를 대충 보고 넘어가서 반복문을 한번밖에 못쓰기 때문에 아이디어를 생각해내는게 힘들었다. 짜고 나니 접두사와 접미사 중복처리하는 부분이 kmp의 아이디어와 비슷한 것 같다.