## 3월 1주차 풀이
---
## 1. BOJ S1 14715 전생했더니 슬라임 연구자였던 건에 관하여 (Easy)
### **문제설명**
* 슬라임을 더이상 쪼갤 수 없을때까지 분할할 때 흠집 개수가 최소가 되는 수를 구하라 

### **Idea**
* 슬라임을 2개씩 분할 할 때, 분할한 두 슬라임 에너지의 곱이 부모 슬라임 에너지와 같아야 함
* 에너지는 2 초과여야 하며 한번 분할할 때마다 흠집이 하나씩 늘어난다.
* 처음에 반복문과 재귀로 어떻게 풀 수 있을까 고민하다가 슬라임을 최종적으로 쪼갰을 때 마지막 에너지들이 원래 슬라임 에너지의 소인수 분해 한 수들이라는 것을 깨달았다.
* 24를 끝까지 분할하면 2, 2, 2, 2, 3이 된다.
* 흠집의 최소 개수는 소인수분해 했을 때 약수들의 개수의 log2를 취해준 값이 된다.



### **구현**
```java
// 소인수분해 해준다
int div = 2, cnt = 0;
while(num != 1) {
    if(num % div == 0) {
        num /= div;
        cnt++;
    }else {
        div++;
    }
}
int result =  (int)Math.ceil(Math.log10(cnt) / Math.log10(2));
System.out.printf("%d\n", cnt == 1 ? 0 : result);
```

### **정리**
한참 고민했던게 무색하게, 원리만 알면 간단히 풀 수 있는 문제였다. 

---
## 2. BOJ G4 6087 레이저 통신 
### **문제설명**
* C에서 목적지인 다른 C까지 이동할 때 설치해야 하는 최소한의 거울 개수를 구하는 문제

### **Idea**
* 한번 방향이 꺾이면 설치해야 하는 거울의 개수를 1 올려주는 식으로 풀 수 있다.
* BFS로 풀 때, 현재 좌표 값, 설치한 거울의 개수, 이전 방향 4가지를 저장했다
* 다음 방향이 이전 방향과 틀리면 cnt + 1 해주고 큐에 저장한다
* 백트래킹을 위해서 visited 배열을 선언해서 cnt를 저장해주고, 현재 설치한 거울의 개수가 visited에 저장된 개수보다 많으면 탐색할 필요가 없으므로 방문하지 않도록 구현했다.

### **구현**
```java
static void bfs() {
    int cnt = 0, dir = 0, nr = 0, nc = 0, r = 0, c = 0;
    Queue<int[]> q = new LinkedList<int[]>();
    
    int y = Pos[0][0], x = Pos[0][1];
    q.add(new int[] {y, x, cnt, 4});
    visited[y][x] = -1;
    map[y][x] = '*';
    
    while(!q.isEmpty()) {
        r = q.peek()[0];	
        c = q.peek()[1];
        cnt = q.peek()[2];
        dir = q.peek()[3];
        q.poll();
        
        if(r == Pos[1][0] && c == Pos[1][1]) {
            min = Math.min(cnt, min);
        }
        
        for(int i=0; i<4; i++) {
            nr = r + dr[i];
            nc = c + dc[i];
            
            if(-1 < nr && nr < H && -1 < nc && nc < W && map[nr][nc] != '*') {
                int _cnt = cnt;
                if(dir != i && dir != 4)
                    _cnt++;
                if(visited[nr][nc] < _cnt) {
                    continue;
                }
                visited[nr][nc] = _cnt;
                q.offer(new int[] {nr, nc, _cnt, i});
            }
        }
    }
}
```

### 정리
처음에 목적지에 도달하면 BFS 탐색을 종료하게 했더니 답이 틀렸었다. 이동 거리가 최소가 돼도 거울의 개수가 더 많을 수 있기 때문에 큐가 빌 때까지 전부 탐색하고, 목적지에 도착할 때마다 거울의 개수가 최소가 되는 값을 갱신해줘야 한다.


---
## 1. BOJ G3 2143 두 배열의 합
### **Idea**
* A, B 배열의 모든 부분배열의 합들을 List에 저장하고 정렬해 준다.
* (A 부분배열의 합) + (B 부분배열의 합) = T가 되는 경우를 찾아준다.
* A와 B 배열의 최대 개수가 각각 1000이기 때문에 2중 for문으로 구할 수 없다.
* T가 5, A가 1일때 B에 4가 몇 개 있는지 알기 위해 lowerBound, upperBound를 구하는 방식으로 풀어줬다.

### **정리**
처음 문제를 봫을 때 문제 이해하는게 오래 걸렸다..ㅠㅠ 답이 int 자료형의 범위를 넘어서는 것을 생각을 못해서 처음에 좀 헤맸다. 최대 부분 배열의 수는 (1000*1000 = 1,000,000) * 1,000,000 = 1,000,000,000,000이므로 답은 long 형으로 구해줘야 한다. 그리고 처음에 부분배열의 합을 저장하는 것을 LinkedList로 구현했는데 시간초과가 났다. LinkedList는 값에 접근하는 데 O(n)만큼 걸리기 때문에 굉장히 느리기 때문이다. ArrayList로 바꾸니까 바로 통과됐다. 값에 따라 어떤 자료형을 써야 하는지 더 잘 생각해 봐야겠다...
