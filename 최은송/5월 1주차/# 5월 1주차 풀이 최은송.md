# 5월 1주차 풀이 최은송
## 1. 백준 G4 1344 축구 
### 문제 정의
1. 90분의 축구 경기를 5분씩 나눴을 때 각 턴마다 두 팀이 최대 한골씩 넣을 수 있고 두 팀의 골을 넣는 확률이 주어진다.
2. 모든 턴이 끝났을 때 적어도 한 팀이 골을 소수로 득점할 확률을 구하시오

### 문제 풀이
1. 90 / 5 = 18, 총 18턴동안 두 팀이 득점을 하는 모든 경우를 구하는 문제이다.
2. dp로 두 팀이 회당 각자 득점하는 경우를 저장하기 위해 dp[19][19][19]: a의 득점/ b의 득점/ 몇번째 턴인지
3. 두 팀이 골을 넣는 경우는 다음과 같다.
    1. a가 넣고, b가 못 넣을 때: a*(1-b)
    2. a가 못 넣고, b가 넣을 때: (1-a) * b
    3. a가 넣고, b가 넣을 때: a * b
    4. a도 못 넣고, b도 못 넣을 때: (1-a) * (1-b)
4. 각 경우 * (다음 경우를 구하기 위한 재귀 호출)의 결과를 리턴한다.
5. 기저조건으로 만약 a의 득점이 소수거나, b의 득점이 소수일 때는 1을 리턴하고, 아닌 경우는 확률을 계산할 필요가 없으니 0을 리턴한다.


### 정리
처음에 기저조건으로 소수일 때 1을 리턴한다는 아이디어를 떠올리지 못해 한참 고민했었다. dp의 뼈대를 익혀놓으면 편하지만 오히려 그 틀에 갇혀 발생을 못하는 것 같다.

----
## 2. 백준 G4 2616 소형기관차 
### 문제 정의
1. 소형기관차 3대가 최대로 끌 수 있는 객실의 수가 주어지고, 최대한 많은 손님을 목적지까지 운송해야 한다.
2. 최대로 운송할 수 있는 손님의 수를 구하시오

### 문제 풀이
1. dp[i][j] : i는 몇번째 소형기관차인지, j는 현재객실부터 최대로 끌 수 있는 객실 수까지 운송하는 손님의 수
2. 승객수가 최대가 되려면 모든 소형기관차는 끌 수 있는 최대 객실(K)를 전부 끌어야 한다.
3. dfs로 현재 객실부터 K개의 객실까지의 인원을 선택하는 경우와, 현재 객실을 선택하지 않을 때의 경우를 비교해야 한다.
4. 점화식

    dp[i][j] = max(dfs(i, j+1), sum[i+K-1] - sum[i] + dfs(i+1, j+K))

### 정리
dp의 기본 구조를 외워두니까 전개할 때 편한 것 같다. 처음에 승객의 수를 반복문을 돌면서 구해야 하나 싶었는데 입력받을 때 누적합으로 저장하는게 낫겠다 싶었다.

----
## 3. 백준 G2 17825 주사위 윷놀이
### 문제 정의
1. 처음 시작 칸에 말 4개가 있다.
2. 말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 10, 20, 30칸에서 시작하면 파란색 화살표를 타야하고 이외에는 빨간색 화살표를 타야 한다. 말이 도착지에 도착하면 이동을 마친다.
3. 게임은 10개의 턴으로 구성돼고, 한 턴당 1~5까지 적힌 주사위 수에 따라 말이 이동한다. 말이 이동하려는 칸에 다른 말이 있으면 이동이 불가. 도착지는 상관 없음
4. 말이 이동을 마칠때마다 칸에 적힌 수가 추가된다. 얻을 수 있는 점수의 최대값을 구해라ㄴ

### 문제 풀이
![map](map.jpeg)
1. 맵을 위와같이 0~32까지 인덱스로 표시.
    - 현재 위치에서 다음에 갈 idx를 저장하는 path[] 생성
    - 10, 20, 30일 때 전환될 방향을 저장하는 corner[] 생성
    - 말들의 현재 위치(idx)를 저장할 horse[] 생성
    - 각 인덱스의 점수를 저장할 score[]  생성
2. 말은 총 4마리로 모든 말들이 움직이는 경우를 dfs로 완탐
3. 현재 말의 위치, 도착할 말의 위치 저장
4. 말이 10, 20, 30에서 시작하면 방향전환을 해주고, 아니면 현재 위치에서 말을 이동
5. 도착한 말의 위치에 이미 다른 말이 있으면 continue
6. 이전 말의 위치, 이동한 말의 위치 방문처리, dfs 호출

### 정리
말이 4개밖에 없고 게임이 10턴이니까 충분히 브루트포스로 풀 수 있겠다 싶었다. 그런데 맵을 어떻게 저장할지 생각하는게 정말 힘들었다. 처음에는 점수를 기준으로 배열을 생성했다가 말들의 이동 처리가 너무 힘들어졌다. 결국 원래 코드를 싹 지우고 어떤 블로그를 참고해서 인덱스를 기준으로 맵을 저장하는 방법으로 바꿔서 다시 짰다. 완탐 로직 자체는 어렵지 않았지만 맵을 구현하는게 너무 힘든 문제였다ㅜ
