## 4월 3주차 풀이
--
## 1. BOJ S2 2644 촌수계산
### **문제 정의**
1. 여러 사람들에 대한 부모 자식 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산해라
2. 만약 어떤 관계도 아니면 -1을 출력

### **문제 풀이**
1. 구해야 하는 두 사람을 x, y로 저장
2. 부모 자식 관계를 인접 행렬로 저장한다. 두 사람이 부모관계임을 표시하는 것이 목적이기 때문에 양방향으로 저장한다. 
3. bfs로 탐색한다. 현재 x에서 부모 관계이건 자식 관계이건 상관 없이 몇촌 관계인 것만 알면 되기 때문에 x의 차출행렬을 탐색하며 연결된 노드를 찾는다. 
4. y를 찾으면 촌수를 출력하고 종료한다.
5. bfs가 끝났는데 리턴하지 못했으면 y를 못찾았다는 의미이므로 -1을 출력하고 종료한다.

### **정리**
처음엔 트리 문제인가? 싶어서 부모는 배열로 저장하고 자식은 linkedList 배열로 저장하고 재귀로 풀었는데 종료조건 찾기가 너무 까다로워서 포기했다. 이 문제의 핵심은 자식, 부모 상관 없이 연결되어 있으면 그 노드를 통해 다른 노드도 탐색할 수 있다는 것이었다. bfs와 dfs의 핵심인데 트리에 꽂혀서 파악이 늦었다. bfs로 풀었지만 dfs로도 다시 풀어봐야겠다.

<br/>
--
## 2. BOJ S1 2502 떡먹는 호랑이 
### **문제 정의**
1. 할머니가 매일 호랑이에게 떡을 주는데 (어제 준 떡 개수 + 그저께 준 떡 개수) 만큼 주어야 한다.
2. 날짜와 호랑이에게 준 떡의 개수가 주어질 때 첫째날, 둘째날에 할머니가 호랑이에게 준 떡의 개수를 출력하시오

### **문제 풀이**
1. 첫째날, 둘째날에 줄 수 있는 모든 떡의 개수를 넣어본 후, dp[N] = dp[N-1] + dp[N-2]라는 식으로 D번째 날에 줄 수 있는 떡의 개수를 구한다.
2. dp[N] == K이면 출력 후 종료

### **정리**
1 ≤ K ≤ 100,000이어서 첫째날과 둘째날에 수를 넣으려면 이중 반복문들 돌기 때문에 시간초과가 걸리지 않을까했었다. 그래서 dp[1], dp[2]에 넣을 값의 범위를 이런저런 수식으로 줄여볼까 했는데 전부 오답처리됐다. 첫째날과 둘째날에 K까지 넣을 수 있게 변경했더니 답이 맞았다. 아무래도 피보나치 수열이고 답이 무조건 있는 문제기 때문에 보통 dp[1], dp[2]가 작을 때 답을 구해서 시간초과가 안뜨는 것 같다.

<br/>
--
## 3. BOJ G4 15685 드래곤 커브 
### **문제 정의**
1. n세대 드래곤 커브는 n-1세대 드래곤 커브를 시계 방향으로 90도 회전시켜서 n-1세대 드래곤 커브 끝에 붙인 것이다.
2. map 크기가 1 ≤ R,C ≤ 100일 때 네 꼭짓점이 모두 드래곤커브의 일부인 1x1 정사각형 개수를 출력하라

### **문제 풀이**
아이디어

- N번째 드래곤 커브를 그릴 때 이전 세대의 커브 방향을 역순으로 90도씩 꺾어서 추가해준다.
- map을 탐색하면서 크기 1의 정사각형 값이 true인지 체크해준다.

입력: 드래곤 커브의 수, 드래곤 커브의 정보 (x, y, 시작방향, 세대)

정의: boolean[][] map = new boolean[101][101]로 방문한 꼭짓점 체크

절차

- 각 드래곤의 정보를 입력받음
- curve 함수
    - 드래곤 커브의 방향을 저장하는 arraylist 생성
    - 세대 0일때 현재 드래곤 방향으로 이동 후 map에 방문 체크
    - list에 방향 저장
        - 드래곤 커브의 세대만큼 반복
            - list의 역순으로 반복하며 dir를 90도로 꺾은 방향 저장, map에 방문 체크

### **정리**
시계 방향으로 드래곤 커브가 붙는데 시계 반대 방향이라고 생각해서 다음 세대 커브의 방향 설정 로직을 찾는데 한참을 삽질했다. 구현 문제는 한자한자 텍스트를 소화시킨다는 생각으로 봐야지ㅠㅠ 