# 6월 3주차 풀이
## 1. BOJ G1 1981 배열에서의이동🚗
### 문제 정의

1. NxN배열에서 (1,1) → (N,N)으로 이동하려 한다.
2. 배열에서 거쳐간 수들 중 최댓값과 최솟값의 차이가 가장 작아지는 경우 그 차이를 출력하시오
3. 2 ≤ N ≤ 100, 0 ≤ 배열의수 ≤ 200

### 문제 풀이

1. min값과 max값을 정해서 bfs 알고리즘을 이용해 최소 최대 범위 안에서 이동할 수 있는지 검사한다.
2. min = 최소값, max = map[0][0]으로 설정해서 dfs에서 min, max 범위 안에서 이동가능하면 min++(범위 줄이기), 아니면 max++(범위 늘리기)

### 정리

도저히 아이디어가 생각나지 않아 블로그를 참고해 풀었다. 처음에 bfs로 풀었는데 메모리 초과가 떠서 dfs로 바꾸니까 성공! min과 max값을 설정하는게 어려웠다.

----
## BOJ G4 1939 중량제한💪
### 문제 정의

1. N(2 ≤ N ≤ 10000)개의 섬과 이 사이를 잇는 M(1≤M≤100000)개의 다리가 있다
2. 각 다리는 중량 제한 C(1≤ C ≤ 1000000000)이 있다. 
3. 한 공장에서 다른 공장으로 물품을 이송해야 하는데 한 번에 옮길 수 있는 물품들 중량의 최댓값을 구하여라

### 문제 풀이

1. Prim으로 푼다
2. M개의 다리들을 LinkedList 배열에 저장
3. Edge class를 만들어서 int to, cost를 기록. 중량의 최댓값을 구하는 것이기 때문에 PriorityQueue에 cost를 내림차순으로 정렬
4. 만약 1 → 2 → 3으로 갈 때 첫번째 다리가 두번째 다리보다 최대 중량이 작으면 그 중 최소 중량을 저장해야 한다. 인접 edge의 cost가 cur의 cost보다 작다면 둘 중 작은 중량을 저장
5. 만약 인접 edge가 도착지이면 ans와 최대값을 비교하고 저장한다. ans = Math.max(ans, edge.cost)
6. 만약 인접 edge가 방문하지 않았다면 pq에 offer
7. pq가 빌때까지 4,5,6을 반복하며 prim 알고리즘 수행
8. ans 출력

### 정리

프림에서 살짝 꼰 문제여서 엄청 어렵진 않았다. 그런데 이 문제 내가 골랐는데 이분탐색 분류에 있었다. 이걸 어떻게 이분탐색으로 풀 수 있을까?

---
## 3. BOJ S1 1389 케빈 베이컨의 6단계 법칙🥓
### 문제정의

1. 친구의 수 N, 친구 관계의 수 M이 주어진다.
2. 친구끼리 연결되어 있을 때 친구에게 도달하는 단계를 케빈 베이컨 수라고 한다. 이 때 케빈 베이컨 수가 가장 작은 사람을 구하라.(같은 사람이 여럿이면 모두 출력)
3. 2 ≤ N ≤ 100, 1 ≤ M ≤ 5000

### 문제풀이

1. 이차원 인접 배열에 친구 관계를 저장한다. (양방향 간선)
2. 중간 k, 출발 i, 도착 j로 각각 유저의 수 N만큼 반복하면서 i →  k → j의 최소 비용을  갱신한다.
3. arr[i][j] = Math.min(arr[i][k] + arr[k][j] + 1, arr[i][j])
4. 만약 i에서 k로 가는게 
5. arr의 한 행을 전부 더했을 때 케빈 파이기 수가 가장 작은 번호를 구한다.

### 정리

오랜만의 플로이드 와샬 문제였다. 처음에 arr를 Integer.MAX_VALUE로 초기화하니 더해주는 과정에서 오버플로가 일어났다. 범위를 잘보자