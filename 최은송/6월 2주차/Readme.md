# 6월 2주차 풀이
## 1. BOJ G5 14520 연구소👩‍🔬
### 문제 정의

1. N*M 직사각형 모양의 연구소에 빈 칸(0), 벽(1), 바이러스(2)가 있다.
2. 바이러스는 상하좌우로 퍼진다.
3. 연구소에 딱 3개의 벽을 설치해서 빈칸(0)의 수를 최대가 되게 했을 때, 안전영역의 최댓값을 구하시오
4. 3 ≤ N, M ≤ 8, 2 ≤ 2의개수 ≤ 10

#### 문제 풀이
1. 칸의 개수가 최대 64이고 선택할 벽의 수가 3개이므로 완전탐색 64C3으로 풀 수 있다.
2. 0인 칸 중에서 3개를 고른다
3. 바이러스를 상하좌우로 퍼트린다.
4. 남은 빈칸의 개수를 세고 최대값과 비교 갱신한다.
#### 정리

문제풀이는 쉽게 구했는데 아무리해도 7퍼센트에서 틀렸습니다가 나왔다. 너무 이상해서 여러 방법을 시도했는데 정답에 짝수 * 홀수 * 자리수를 더해줄 때 각각 long타입으로 바꿔주지 않아서 생긴 문제였다.

----

## 2. BOJ 9935 문자열 폭발💣
### 문제 정의

1. 문자열에 폭발 문자열을 포함하고 있는 경우 모든 포함 문자열은 폭발하고 남은 문자열은 차례대로 붙는다.
2. 문자열에 폭발 문자열이 없을때까지 반복하고 남은 문자열을 출력하시오
3. 만약 문자열이 없어지면 "FRULA"를 출력하시오
4. 문자열의 길이는 1 ~ 1,000,000까지고 폭발 문자열은 36 이하 자연수

### 문제 풀이

1. 문자열의 길이가 백만이기 때문에 반복문 한번으로 모든 문자열을 폭발시켜야 한다.
2. 그러므로 문자열의 끝과 폭탄의 끝을 비교해서 같으면 폭탄 길이만큼 문자열을 비교해서 제거해주는 방식으로 문자열을 줄여나간다.
3. 폭발일 끝나고 문자열의 idx가 0이면 문자열이 빈 것이므로 "FRULA"를 출력해주고 아니면 stringbuildr에 붙여서 출력해준다.

### 정리

처음엔 문자열의 앞부터 폭탄을 비교하는 방식으로 deque를 써서 구현했는데 메모리 초과가 났다. 디큐를 안쓰고 배열을 쓰자니 앞에서부터 비교하면 무조건 시간초과가 날 것 같아서 고민했는데 폭탄 뒤부터 비교해나가면 시간복잡도가1,000,000 * 36 = 3600만번밖에 안되는걸 깨달으니 금방 풀렸다.

---
## 3. BOJ G4 1918 색상환 🎨
### 문제정의

1. N개의 도시 사이에 M개의 도로가 있다. K개의 도로를 포장하면 이동비용이 0이 된다. 도로는 양방향이다.
2. K개 이하의 도로를 포장하여 얻을 수 있는 최소 시간을 출력하시오
3. 1 ≤ N ≤ 10000, 1 ≤ M ≤ 50000, 1 ≤ K ≤ 20

### 문제 풀이

1. `dist[N+1][K+1]` 배열에 도로포장 k개를 깔았을 때 최소비용을 저장한다.
2. PriorityQueue에 `Edge(다음도시, 이동비용, k개수)`를 저장해서 이동비용이 작은 애들부터 poll해서 이동거리를 계산한다.
3. poll한 edge에서 인접한 도시를 탐색한다.
    1. 도로포장을 안하는 경우: 만약 `dist[next][k]`가 현재 도시까지 이동비용 + 다음 도시로 이동할 비용보다 클 경우. `dist[to][k]` = `현재이동비용 + 다음 도시로 이동할 비용`으로 갱신하고 pq에 `Edge(다음도시, 이동비용, k)`를 넣어준다
    2. 도로포장을 하는 경우: 현재 edge의 k가 K보다 작고 `dist[next][k]`가 현재 도시까지 오는 비용보다 클 경우 최소값 갱신. pq에 `Edge(다음 도시, 현재도시까지 이동비용, k+1) `넣어준다.
4. pq가 빌때까지 모든 탐색을 마치면 `dist[N][0~K]`까지 최소값을 찾아서 출력한다.
5. 주의사항! 도로의 수가 50만개고, 이동비용은 100만이므로 long타입을 사용해야 한다.

### 정리

결과값을 저장하는 배열이 이차원이라서 처음에 많이 헷갈렸다. 표를 그리면서 푸니까 그래도 어떻게 풀어야할 지 감이 잡혔다. 멍청하게 도로가 양방향인걸 못보고 한참 헤매다가 겨우 찾아서 통과했다ㅠㅠ입력을 잘 봐야지..
